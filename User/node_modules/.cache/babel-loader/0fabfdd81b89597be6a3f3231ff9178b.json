{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n\"use strict\";\n\nvar _ = require('underscore');\n\nvar errors = require('web3-core-helpers').errors;\n\nvar formatters = require('web3-core-helpers').formatters;\n\nvar utils = require('web3-utils');\n\nvar promiEvent = require('web3-core-promievent');\n\nvar Subscriptions = require('web3-core-subscriptions').subscriptions;\n\nvar TIMEOUTBLOCK = 50;\nvar POLLINGTIMEOUT = 15 * TIMEOUTBLOCK; // ~average block time (seconds) * TIMEOUTBLOCK\n\nvar CONFIRMATIONBLOCKS = 24;\n\nvar Method = function Method(options) {\n  if (!options.call || !options.name) {\n    throw new Error('When creating a method you need to provide at least the \"name\" and \"call\" property.');\n  }\n\n  this.name = options.name;\n  this.call = options.call;\n  this.params = options.params || 0;\n  this.inputFormatter = options.inputFormatter;\n  this.outputFormatter = options.outputFormatter;\n  this.transformPayload = options.transformPayload;\n  this.extraFormatters = options.extraFormatters;\n  this.requestManager = options.requestManager; // reference to eth.accounts\n\n  this.accounts = options.accounts;\n  this.defaultBlock = options.defaultBlock || 'latest';\n  this.defaultAccount = options.defaultAccount || null;\n};\n\nMethod.prototype.setRequestManager = function (requestManager, accounts) {\n  this.requestManager = requestManager; // reference to eth.accounts\n\n  if (accounts) {\n    this.accounts = accounts;\n  }\n};\n\nMethod.prototype.createFunction = function (requestManager, accounts) {\n  var func = this.buildCall();\n  func.call = this.call;\n  this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts);\n  return func;\n};\n\nMethod.prototype.attachToObject = function (obj) {\n  var func = this.buildCall();\n  func.call = this.call;\n  var name = this.name.split('.');\n\n  if (name.length > 1) {\n    obj[name[0]] = obj[name[0]] || {};\n    obj[name[0]][name[1]] = func;\n  } else {\n    obj[name[0]] = func;\n  }\n};\n/**\n * Should be used to determine name of the jsonrpc method based on arguments\n *\n * @method getCall\n * @param {Array} arguments\n * @return {String} name of jsonrpc method\n */\n\n\nMethod.prototype.getCall = function (args) {\n  return _.isFunction(this.call) ? this.call(args) : this.call;\n};\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\n\n\nMethod.prototype.extractCallback = function (args) {\n  if (_.isFunction(args[args.length - 1])) {\n    return args.pop(); // modify the args array!\n  }\n};\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\n\n\nMethod.prototype.validateArgs = function (args) {\n  if (args.length !== this.params) {\n    throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\n  }\n};\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\n\n\nMethod.prototype.formatInput = function (args) {\n  var _this = this;\n\n  if (!this.inputFormatter) {\n    return args;\n  }\n\n  return this.inputFormatter.map(function (formatter, index) {\n    // bind this for defaultBlock, and defaultAccount\n    return formatter ? formatter.call(_this, args[index]) : args[index];\n  });\n};\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\n\n\nMethod.prototype.formatOutput = function (result) {\n  var _this = this;\n\n  if (_.isArray(result)) {\n    return result.map(function (res) {\n      return _this.outputFormatter && res ? _this.outputFormatter(res) : res;\n    });\n  } else {\n    return this.outputFormatter && result ? this.outputFormatter(result) : result;\n  }\n};\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\n\n\nMethod.prototype.toPayload = function (args) {\n  var call = this.getCall(args);\n  var callback = this.extractCallback(args);\n  var params = this.formatInput(args);\n  this.validateArgs(params);\n  var payload = {\n    method: call,\n    params: params,\n    callback: callback\n  };\n\n  if (this.transformPayload) {\n    payload = this.transformPayload(payload);\n  }\n\n  return payload;\n};\n\nMethod.prototype._confirmTransaction = function (defer, result, payload) {\n  var method = this,\n      promiseResolved = false,\n      canUnsubscribe = true,\n      timeoutCount = 0,\n      confirmationCount = 0,\n      intervalId = null,\n      receiptJSON = '',\n      gasProvided = _.isObject(payload.params[0]) && payload.params[0].gas ? payload.params[0].gas : null,\n      isContractDeployment = _.isObject(payload.params[0]) && payload.params[0].data && payload.params[0].from && !payload.params[0].to; // add custom send Methods\n\n  var _ethereumCalls = [new Method({\n    name: 'getTransactionReceipt',\n    call: 'eth_getTransactionReceipt',\n    params: 1,\n    inputFormatter: [null],\n    outputFormatter: formatters.outputTransactionReceiptFormatter\n  }), new Method({\n    name: 'getCode',\n    call: 'eth_getCode',\n    params: 2,\n    inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]\n  }), new Subscriptions({\n    name: 'subscribe',\n    type: 'eth',\n    subscriptions: {\n      'newBlockHeaders': {\n        subscriptionName: 'newHeads',\n        // replace subscription with this name\n        params: 0,\n        outputFormatter: formatters.outputBlockFormatter\n      }\n    }\n  })]; // attach methods to this._ethereumCall\n\n  var _ethereumCall = {};\n\n  _.each(_ethereumCalls, function (mthd) {\n    mthd.attachToObject(_ethereumCall);\n    mthd.requestManager = method.requestManager; // assign rather than call setRequestManager()\n  }); // fire \"receipt\" and confirmation events and resolve after\n\n\n  var checkConfirmation = function checkConfirmation(existingReceipt, isPolling, err, blockHeader, sub) {\n    if (!err) {\n      // create fake unsubscribe\n      if (!sub) {\n        sub = {\n          unsubscribe: function unsubscribe() {\n            clearInterval(intervalId);\n          }\n        };\n      } // if we have a valid receipt we don't need to send a request\n\n\n      return (existingReceipt ? promiEvent.resolve(existingReceipt) : _ethereumCall.getTransactionReceipt(result)). // catch error from requesting receipt\n      catch(function (err) {\n        sub.unsubscribe();\n        promiseResolved = true;\n\n        utils._fireError({\n          message: 'Failed to check for transaction receipt:',\n          data: err\n        }, defer.eventEmitter, defer.reject);\n      }) // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n      .then(function (receipt) {\n        if (!receipt || !receipt.blockHash) {\n          throw new Error('Receipt missing or blockHash null');\n        } // apply extra formatters\n\n\n        if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n          receipt = method.extraFormatters.receiptFormatter(receipt);\n        } // check if confirmation listener exists\n\n\n        if (defer.eventEmitter.listeners('confirmation').length > 0) {\n          // If there was an immediately retrieved receipt, it's already\n          // been confirmed by the direct call to checkConfirmation needed\n          // for parity instant-seal\n          if (existingReceipt === undefined || confirmationCount !== 0) {\n            defer.eventEmitter.emit('confirmation', confirmationCount, receipt);\n          }\n\n          canUnsubscribe = false;\n          confirmationCount++;\n\n          if (confirmationCount === CONFIRMATIONBLOCKS + 1) {\n            // add 1 so we account for conf 0\n            sub.unsubscribe();\n            defer.eventEmitter.removeAllListeners();\n          }\n        }\n\n        return receipt;\n      }) // CHECK for CONTRACT DEPLOYMENT\n      .then(function (receipt) {\n        if (isContractDeployment && !promiseResolved) {\n          if (!receipt.contractAddress) {\n            if (canUnsubscribe) {\n              sub.unsubscribe();\n              promiseResolved = true;\n            }\n\n            utils._fireError(new Error('The transaction receipt didn\\'t contain a contract address.'), defer.eventEmitter, defer.reject);\n\n            return;\n          }\n\n          _ethereumCall.getCode(receipt.contractAddress, function (e, code) {\n            if (!code) {\n              return;\n            }\n\n            if (code.length > 2) {\n              defer.eventEmitter.emit('receipt', receipt); // if contract, return instance instead of receipt\n\n              if (method.extraFormatters && method.extraFormatters.contractDeployFormatter) {\n                defer.resolve(method.extraFormatters.contractDeployFormatter(receipt));\n              } else {\n                defer.resolve(receipt);\n              } // need to remove listeners, as they aren't removed automatically when succesfull\n\n\n              if (canUnsubscribe) {\n                defer.eventEmitter.removeAllListeners();\n              }\n            } else {\n              utils._fireError(new Error('The contract code couldn\\'t be stored, please check your gas limit.'), defer.eventEmitter, defer.reject);\n            }\n\n            if (canUnsubscribe) {\n              sub.unsubscribe();\n            }\n\n            promiseResolved = true;\n          });\n        }\n\n        return receipt;\n      }) // CHECK for normal tx check for receipt only\n      .then(function (receipt) {\n        if (!isContractDeployment && !promiseResolved) {\n          if (!receipt.outOfGas && (!gasProvided || gasProvided !== receipt.gasUsed) && (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined')) {\n            defer.eventEmitter.emit('receipt', receipt);\n            defer.resolve(receipt); // need to remove listeners, as they aren't removed automatically when succesfull\n\n            if (canUnsubscribe) {\n              defer.eventEmitter.removeAllListeners();\n            }\n          } else {\n            receiptJSON = JSON.stringify(receipt, null, 2);\n\n            if (receipt.status === false || receipt.status === '0x0') {\n              utils._fireError(new Error(\"Transaction has been reverted by the EVM:\\n\" + receiptJSON), defer.eventEmitter, defer.reject);\n            } else {\n              utils._fireError(new Error(\"Transaction ran out of gas. Please provide more gas:\\n\" + receiptJSON), defer.eventEmitter, defer.reject);\n            }\n          }\n\n          if (canUnsubscribe) {\n            sub.unsubscribe();\n          }\n\n          promiseResolved = true;\n        }\n      }) // time out the transaction if not mined after 50 blocks\n      .catch(function () {\n        timeoutCount++; // check to see if we are http polling\n\n        if (!!isPolling) {\n          // polling timeout is different than TIMEOUTBLOCK blocks since we are triggering every second\n          if (timeoutCount - 1 >= POLLINGTIMEOUT) {\n            sub.unsubscribe();\n            promiseResolved = true;\n\n            utils._fireError(new Error('Transaction was not mined within' + POLLINGTIMEOUT + ' seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n          }\n        } else {\n          if (timeoutCount - 1 >= TIMEOUTBLOCK) {\n            sub.unsubscribe();\n            promiseResolved = true;\n\n            utils._fireError(new Error('Transaction was not mined within 50 blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n          }\n        }\n      });\n    } else {\n      sub.unsubscribe();\n      promiseResolved = true;\n\n      utils._fireError({\n        message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.',\n        data: err\n      }, defer.eventEmitter, defer.reject);\n    }\n  }; // start watching for confirmation depending on the support features of the provider\n\n\n  var startWatching = function (existingReceipt) {\n    // if provider allows PUB/SUB\n    if (_.isFunction(this.requestManager.provider.on)) {\n      _ethereumCall.subscribe('newBlockHeaders', checkConfirmation.bind(null, existingReceipt, false));\n    } else {\n      intervalId = setInterval(checkConfirmation.bind(null, existingReceipt, true), 1000);\n    }\n  }.bind(this); // first check if we already have a confirmed transaction\n\n\n  _ethereumCall.getTransactionReceipt(result).then(function (receipt) {\n    if (receipt && receipt.blockHash) {\n      if (defer.eventEmitter.listeners('confirmation').length > 0) {\n        // We must keep on watching for new Blocks, if a confirmation listener is present\n        startWatching(receipt);\n      }\n\n      checkConfirmation(receipt, false);\n    } else if (!promiseResolved) {\n      startWatching();\n    }\n  }).catch(function () {\n    if (!promiseResolved) startWatching();\n  });\n};\n\nvar getWallet = function getWallet(from, accounts) {\n  var wallet = null; // is index given\n\n  if (_.isNumber(from)) {\n    wallet = accounts.wallet[from]; // is account given\n  } else if (_.isObject(from) && from.address && from.privateKey) {\n    wallet = from; // search in wallet for address\n  } else {\n    wallet = accounts.wallet[from.toLowerCase()];\n  }\n\n  return wallet;\n};\n\nMethod.prototype.buildCall = function () {\n  var method = this,\n      isSendTx = method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction'; // || method.call === 'personal_sendTransaction'\n  // actual send function\n\n  var send = function send() {\n    var defer = promiEvent(!isSendTx),\n        payload = method.toPayload(Array.prototype.slice.call(arguments)); // CALLBACK function\n\n    var sendTxCallback = function sendTxCallback(err, result) {\n      try {\n        result = method.formatOutput(result);\n      } catch (e) {\n        err = e;\n      }\n\n      if (result instanceof Error) {\n        err = result;\n      }\n\n      if (!err) {\n        if (payload.callback) {\n          payload.callback(null, result);\n        }\n      } else {\n        if (err.error) {\n          err = err.error;\n        }\n\n        return utils._fireError(err, defer.eventEmitter, defer.reject, payload.callback);\n      } // return PROMISE\n\n\n      if (!isSendTx) {\n        if (!err) {\n          defer.resolve(result);\n        } // return PROMIEVENT\n\n      } else {\n        defer.eventEmitter.emit('transactionHash', result);\n\n        method._confirmTransaction(defer, result, payload);\n      }\n    }; // SENDS the SIGNED SIGNATURE\n\n\n    var sendSignedTx = function sendSignedTx(sign) {\n      var signedPayload = _.extend({}, payload, {\n        method: 'eth_sendRawTransaction',\n        params: [sign.rawTransaction]\n      });\n\n      method.requestManager.send(signedPayload, sendTxCallback);\n    };\n\n    var sendRequest = function sendRequest(payload, method) {\n      if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n        var wallet; // ETH_SENDTRANSACTION\n\n        if (payload.method === 'eth_sendTransaction') {\n          var tx = payload.params[0];\n          wallet = getWallet(_.isObject(tx) ? tx.from : null, method.accounts); // If wallet was found, sign tx, and send using sendRawTransaction\n\n          if (wallet && wallet.privateKey) {\n            return method.accounts.signTransaction(_.omit(tx, 'from'), wallet.privateKey).then(sendSignedTx);\n          } // ETH_SIGN\n\n        } else if (payload.method === 'eth_sign') {\n          var data = payload.params[1];\n          wallet = getWallet(payload.params[0], method.accounts); // If wallet was found, sign tx, and send using sendRawTransaction\n\n          if (wallet && wallet.privateKey) {\n            var sign = method.accounts.sign(data, wallet.privateKey);\n\n            if (payload.callback) {\n              payload.callback(null, sign.signature);\n            }\n\n            defer.resolve(sign.signature);\n            return;\n          }\n        }\n      }\n\n      return method.requestManager.send(payload, sendTxCallback);\n    }; // Send the actual transaction\n\n\n    if (isSendTx && _.isObject(payload.params[0]) && typeof payload.params[0].gasPrice === 'undefined') {\n      var getGasPrice = new Method({\n        name: 'getGasPrice',\n        call: 'eth_gasPrice',\n        params: 0\n      }).createFunction(method.requestManager);\n      getGasPrice(function (err, gasPrice) {\n        if (gasPrice) {\n          payload.params[0].gasPrice = gasPrice;\n        }\n\n        sendRequest(payload, method);\n      });\n    } else {\n      sendRequest(payload, method);\n    }\n\n    return defer.eventEmitter;\n  }; // necessary to attach things to the method\n\n\n  send.method = method; // necessary for batch requests\n\n  send.request = this.request.bind(this);\n  return send;\n};\n/**\n * Should be called to create the pure JSONRPC request which can be used in a batch request\n *\n * @method request\n * @return {Object} jsonrpc request\n */\n\n\nMethod.prototype.request = function () {\n  var payload = this.toPayload(Array.prototype.slice.call(arguments));\n  payload.format = this.formatOutput.bind(this);\n  return payload;\n};\n\nmodule.exports = Method;","map":null,"metadata":{},"sourceType":"script"}