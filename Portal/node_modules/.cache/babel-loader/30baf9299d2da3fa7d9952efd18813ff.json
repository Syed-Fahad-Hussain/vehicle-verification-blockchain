{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('web3-providers'), require('web3-utils'), require('web3-core-helpers'), require('web3-core-method'), require('@babel/runtime/helpers/classCallCheck'), require('@babel/runtime/helpers/createClass'), require('@babel/runtime/helpers/possibleConstructorReturn'), require('@babel/runtime/helpers/getPrototypeOf'), require('@babel/runtime/helpers/inherits'), require('@babel/runtime/helpers/assertThisInitialized'), require('lodash/isUndefined'), require('lodash/isNull'), require('lodash/isObject'), require('lodash/isBoolean'), require('lodash/isString'), require('lodash/has'), require('lodash/extend'), require('eth-lib/lib/account'), require('eth-lib/lib/hash'), require('eth-lib/lib/rlp'), require('eth-lib/lib/nat'), require('eth-lib/lib/bytes'), require('scrypt.js'), require('uuid'), require('web3-core')) : typeof define === 'function' && define.amd ? define(['exports', 'web3-providers', 'web3-utils', 'web3-core-helpers', 'web3-core-method', '@babel/runtime/helpers/classCallCheck', '@babel/runtime/helpers/createClass', '@babel/runtime/helpers/possibleConstructorReturn', '@babel/runtime/helpers/getPrototypeOf', '@babel/runtime/helpers/inherits', '@babel/runtime/helpers/assertThisInitialized', 'lodash/isUndefined', 'lodash/isNull', 'lodash/isObject', 'lodash/isBoolean', 'lodash/isString', 'lodash/has', 'lodash/extend', 'eth-lib/lib/account', 'eth-lib/lib/hash', 'eth-lib/lib/rlp', 'eth-lib/lib/nat', 'eth-lib/lib/bytes', 'scrypt.js', 'uuid', 'web3-core'], factory) : factory(global.Web3EthAccounts = {}, global.web3Providers, global.Utils, global.web3CoreHelpers, global.web3CoreMethod, global._classCallCheck, global._createClass, global._possibleConstructorReturn, global._getPrototypeOf, global._inherits, global._assertThisInitialized, global.isUndefined, global.isNull, global.isObject, global.isBoolean, global.isString, global.has, global.extend, global.Account, global.Hash, global.RLP, global.Nat, global.Bytes, global.scryptsy, global.uuid, global.web3Core);\n})(this, function (exports, web3Providers, Utils, web3CoreHelpers, web3CoreMethod, _classCallCheck, _createClass, _possibleConstructorReturn, _getPrototypeOf, _inherits, _assertThisInitialized, isUndefined, isNull, isObject, isBoolean, isString, has, extend, Account, Hash, RLP, Nat, Bytes, scryptsy, uuid, web3Core) {\n  'use strict';\n\n  _classCallCheck = _classCallCheck && _classCallCheck.hasOwnProperty('default') ? _classCallCheck['default'] : _classCallCheck;\n  _createClass = _createClass && _createClass.hasOwnProperty('default') ? _createClass['default'] : _createClass;\n  _possibleConstructorReturn = _possibleConstructorReturn && _possibleConstructorReturn.hasOwnProperty('default') ? _possibleConstructorReturn['default'] : _possibleConstructorReturn;\n  _getPrototypeOf = _getPrototypeOf && _getPrototypeOf.hasOwnProperty('default') ? _getPrototypeOf['default'] : _getPrototypeOf;\n  _inherits = _inherits && _inherits.hasOwnProperty('default') ? _inherits['default'] : _inherits;\n  _assertThisInitialized = _assertThisInitialized && _assertThisInitialized.hasOwnProperty('default') ? _assertThisInitialized['default'] : _assertThisInitialized;\n  isUndefined = isUndefined && isUndefined.hasOwnProperty('default') ? isUndefined['default'] : isUndefined;\n  isNull = isNull && isNull.hasOwnProperty('default') ? isNull['default'] : isNull;\n  isObject = isObject && isObject.hasOwnProperty('default') ? isObject['default'] : isObject;\n  isBoolean = isBoolean && isBoolean.hasOwnProperty('default') ? isBoolean['default'] : isBoolean;\n  isString = isString && isString.hasOwnProperty('default') ? isString['default'] : isString;\n  has = has && has.hasOwnProperty('default') ? has['default'] : has;\n  extend = extend && extend.hasOwnProperty('default') ? extend['default'] : extend;\n  Account = Account && Account.hasOwnProperty('default') ? Account['default'] : Account;\n  Hash = Hash && Hash.hasOwnProperty('default') ? Hash['default'] : Hash;\n  RLP = RLP && RLP.hasOwnProperty('default') ? RLP['default'] : RLP;\n  Nat = Nat && Nat.hasOwnProperty('default') ? Nat['default'] : Nat;\n  Bytes = Bytes && Bytes.hasOwnProperty('default') ? Bytes['default'] : Bytes;\n  scryptsy = scryptsy && scryptsy.hasOwnProperty('default') ? scryptsy['default'] : scryptsy;\n  uuid = uuid && uuid.hasOwnProperty('default') ? uuid['default'] : uuid;\n\n  var MethodFactory = function (_AbstractMethodFactor) {\n    _inherits(MethodFactory, _AbstractMethodFactor);\n\n    function MethodFactory(methodModuleFactory, utils, formatters) {\n      var _this;\n\n      _classCallCheck(this, MethodFactory);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(MethodFactory).call(this, methodModuleFactory, utils, formatters));\n      _this.methods = {\n        getGasPrice: web3CoreMethod.GetGasPriceMethod,\n        getTransactionCount: web3CoreMethod.GetTransactionCountMethod,\n        getId: web3CoreMethod.VersionMethod\n      };\n      return _this;\n    }\n\n    return MethodFactory;\n  }(web3CoreMethod.AbstractMethodFactory);\n\n  var cryp = typeof global === 'undefined' ? require('crypto-browserify') : require('crypto');\n\n  var isNot = function isNot(value) {\n    return isUndefined(value) || isNull(value);\n  };\n\n  var trimLeadingZero = function trimLeadingZero(hex) {\n    while (hex && hex.startsWith('0x0')) {\n      hex = \"0x\".concat(hex.slice(3));\n    }\n\n    return hex;\n  };\n\n  var makeEven = function makeEven(hex) {\n    if (hex.length % 2 === 1) {\n      hex = hex.replace('0x', '0x0');\n    }\n\n    return hex;\n  };\n\n  var Accounts = function (_AbstractWeb3Module) {\n    _inherits(Accounts, _AbstractWeb3Module);\n\n    function Accounts(provider, providersModuleFactory, methodModuleFactory, methodFactory, utils, formatters, options) {\n      var _this2;\n\n      _classCallCheck(this, Accounts);\n\n      _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Accounts).call(this, provider, providersModuleFactory, methodModuleFactory, methodFactory, options));\n      _this2.utils = utils;\n      _this2.formatters = formatters;\n      _this2.wallet = new Wallet(_assertThisInitialized(_assertThisInitialized(_this2)));\n      return _this2;\n    }\n\n    _createClass(Accounts, [{\n      key: \"_addAccountFunctions\",\n      value: function _addAccountFunctions(account) {\n        var _this3 = this;\n\n        account.signTransaction = function (tx, callback) {\n          return _this3.signTransaction(tx, account.privateKey, callback);\n        };\n\n        account.sign = function (data) {\n          return _this3.sign(data, account.privateKey);\n        };\n\n        account.encrypt = function (password, options) {\n          return _this3.encrypt(account.privateKey, password, options);\n        };\n\n        return account;\n      }\n    }, {\n      key: \"create\",\n      value: function create(entropy) {\n        return this._addAccountFunctions(Account.create(entropy || this.utils.randomHex(32)));\n      }\n    }, {\n      key: \"privateKeyToAccount\",\n      value: function privateKeyToAccount(privateKey) {\n        return this._addAccountFunctions(Account.fromPrivate(privateKey));\n      }\n    }, {\n      key: \"signTransaction\",\n      value: function signTransaction(tx, privateKey, callback) {\n        var _this = this;\n\n        var error = false;\n        var result;\n\n        callback = callback || function () {};\n\n        if (!tx) {\n          error = new Error('No transaction object given!');\n          callback(error);\n          return Promise.reject(error);\n        }\n\n        function signed(tx) {\n          if (!tx.gas && !tx.gasLimit) {\n            error = new Error('gas is missing');\n          }\n\n          if (tx.nonce < 0 || tx.gas < 0 || tx.gasPrice < 0 || tx.chainId < 0) {\n            error = new Error('Gas, gasPrice, nonce or chainId is lower than 0');\n          }\n\n          if (error) {\n            callback(error);\n            return Promise.reject(error);\n          }\n\n          try {\n            tx = _this.formatters.inputCallFormatter(tx);\n            var transaction = tx;\n            transaction.to = tx.to || '0x';\n            transaction.data = tx.data || '0x';\n            transaction.value = tx.value || '0x';\n            transaction.chainId = _this.utils.numberToHex(tx.chainId);\n            var rlpEncoded = RLP.encode([Bytes.fromNat(transaction.nonce), Bytes.fromNat(transaction.gasPrice), Bytes.fromNat(transaction.gas), transaction.to.toLowerCase(), Bytes.fromNat(transaction.value), transaction.data, Bytes.fromNat(transaction.chainId || '0x1'), '0x', '0x']);\n            var hash = Hash.keccak256(rlpEncoded);\n            var signature = Account.makeSigner(Nat.toNumber(transaction.chainId || '0x1') * 2 + 35)(Hash.keccak256(rlpEncoded), privateKey);\n            var rawTx = RLP.decode(rlpEncoded).slice(0, 6).concat(Account.decodeSignature(signature));\n            rawTx[6] = makeEven(trimLeadingZero(rawTx[6]));\n            rawTx[7] = makeEven(trimLeadingZero(rawTx[7]));\n            rawTx[8] = makeEven(trimLeadingZero(rawTx[8]));\n            var rawTransaction = RLP.encode(rawTx);\n            var values = RLP.decode(rawTransaction);\n            result = {\n              messageHash: hash,\n              v: trimLeadingZero(values[6]),\n              r: trimLeadingZero(values[7]),\n              s: trimLeadingZero(values[8]),\n              rawTransaction: rawTransaction\n            };\n          } catch (error) {\n            callback(error);\n            return Promise.reject(error);\n          }\n\n          callback(null, result);\n          return result;\n        }\n\n        if (tx.nonce !== undefined && tx.chainId !== undefined && tx.gasPrice !== undefined) {\n          return Promise.resolve(signed(tx));\n        }\n\n        return Promise.all([isNot(tx.chainId) ? _this.getId() : tx.chainId, isNot(tx.gasPrice) ? _this.getGasPrice() : tx.gasPrice, isNot(tx.nonce) ? _this.getTransactionCount(_this.privateKeyToAccount(privateKey).address) : tx.nonce]).then(function (args) {\n          if (isNot(args[0]) || isNot(args[1]) || isNot(args[2])) {\n            throw new Error(\"One of the values 'chainId', 'gasPrice', or 'nonce' couldn't be fetched: \".concat(JSON.stringify(args)));\n          }\n\n          return signed(extend(tx, {\n            chainId: args[0],\n            gasPrice: args[1],\n            nonce: args[2]\n          }));\n        });\n      }\n    }, {\n      key: \"recoverTransaction\",\n      value: function recoverTransaction(rawTx) {\n        var values = RLP.decode(rawTx);\n        var signature = Account.encodeSignature(values.slice(6, 9));\n        var recovery = Bytes.toNumber(values[6]);\n        var extraData = recovery < 35 ? [] : [Bytes.fromNumber(recovery - 35 >> 1), '0x', '0x'];\n        var signingData = values.slice(0, 6).concat(extraData);\n        var signingDataHex = RLP.encode(signingData);\n        return Account.recover(Hash.keccak256(signingDataHex), signature);\n      }\n    }, {\n      key: \"hashMessage\",\n      value: function hashMessage(data) {\n        var message = this.utils.isHexStrict(data) ? this.utils.hexToBytes(data) : data;\n        var messageBuffer = Buffer.from(message);\n        var preamble = \"\\x19Ethereum Signed Message:\\n\".concat(message.length);\n        var preambleBuffer = Buffer.from(preamble);\n        var ethMessage = Buffer.concat([preambleBuffer, messageBuffer]);\n        return Hash.keccak256s(ethMessage);\n      }\n    }, {\n      key: \"sign\",\n      value: function sign(data, privateKey) {\n        var hash = this.hashMessage(data);\n        var signature = Account.sign(hash, privateKey);\n        var vrs = Account.decodeSignature(signature);\n        return {\n          message: data,\n          messageHash: hash,\n          v: vrs[0],\n          r: vrs[1],\n          s: vrs[2],\n          signature: signature\n        };\n      }\n    }, {\n      key: \"recover\",\n      value: function recover(message, signature, preFixed) {\n        var args = [].slice.apply(arguments);\n\n        if (isObject(message)) {\n          return this.recover(message.messageHash, Account.encodeSignature([message.v, message.r, message.s]), true);\n        }\n\n        if (!preFixed) {\n          message = this.hashMessage(message);\n        }\n\n        if (args.length >= 4) {\n          preFixed = args.slice(-1)[0];\n          preFixed = isBoolean(preFixed) ? preFixed : false;\n          return this.recover(message, Account.encodeSignature(args.slice(1, 4)), preFixed);\n        }\n\n        return Account.recover(message, signature);\n      }\n    }, {\n      key: \"decrypt\",\n      value: function decrypt(v3Keystore, password, nonStrict) {\n        if (!isString(password)) {\n          throw new Error('No password given.');\n        }\n\n        var json = isObject(v3Keystore) ? v3Keystore : JSON.parse(nonStrict ? v3Keystore.toLowerCase() : v3Keystore);\n\n        if (json.version !== 3) {\n          throw new Error('Not a valid V3 wallet');\n        }\n\n        var derivedKey;\n        var kdfparams;\n\n        if (json.crypto.kdf === 'scrypt') {\n          kdfparams = json.crypto.kdfparams;\n          derivedKey = scryptsy(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n        } else if (json.crypto.kdf === 'pbkdf2') {\n          kdfparams = json.crypto.kdfparams;\n\n          if (kdfparams.prf !== 'hmac-sha256') {\n            throw new Error('Unsupported parameters to PBKDF2');\n          }\n\n          derivedKey = cryp.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256');\n        } else {\n          throw new Error('Unsupported key derivation scheme');\n        }\n\n        var ciphertext = Buffer.from(json.crypto.ciphertext, 'hex');\n        var mac = this.utils.sha3(Buffer.concat([derivedKey.slice(16, 32), ciphertext])).replace('0x', '');\n\n        if (mac !== json.crypto.mac) {\n          throw new Error('Key derivation failed - possibly wrong password');\n        }\n\n        var decipher = cryp.createDecipheriv(json.crypto.cipher, derivedKey.slice(0, 16), Buffer.from(json.crypto.cipherparams.iv, 'hex'));\n        var seed = \"0x\".concat(Buffer.concat([decipher.update(ciphertext), decipher.final()]).toString('hex'));\n        return this.privateKeyToAccount(seed);\n      }\n    }, {\n      key: \"encrypt\",\n      value: function encrypt(privateKey, password, options) {\n        var account = this.privateKeyToAccount(privateKey);\n        options = options || {};\n        var salt = options.salt || cryp.randomBytes(32);\n        var iv = options.iv || cryp.randomBytes(16);\n        var derivedKey;\n        var kdf = options.kdf || 'scrypt';\n        var kdfparams = {\n          dklen: options.dklen || 32,\n          salt: salt.toString('hex')\n        };\n\n        if (kdf === 'pbkdf2') {\n          kdfparams.c = options.c || 262144;\n          kdfparams.prf = 'hmac-sha256';\n          derivedKey = cryp.pbkdf2Sync(Buffer.from(password), salt, kdfparams.c, kdfparams.dklen, 'sha256');\n        } else if (kdf === 'scrypt') {\n          kdfparams.n = options.n || 8192;\n          kdfparams.r = options.r || 8;\n          kdfparams.p = options.p || 1;\n          derivedKey = scryptsy(Buffer.from(password), salt, kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n        } else {\n          throw new Error('Unsupported kdf');\n        }\n\n        var cipher = cryp.createCipheriv(options.cipher || 'aes-128-ctr', derivedKey.slice(0, 16), iv);\n\n        if (!cipher) {\n          throw new Error('Unsupported cipher');\n        }\n\n        var ciphertext = Buffer.concat([cipher.update(Buffer.from(account.privateKey.replace('0x', ''), 'hex')), cipher.final()]);\n        var mac = this.utils.sha3(Buffer.concat([derivedKey.slice(16, 32), Buffer.from(ciphertext, 'hex')])).replace('0x', '');\n        return {\n          version: 3,\n          id: uuid.v4({\n            random: options.uuid || cryp.randomBytes(16)\n          }),\n          address: account.address.toLowerCase().replace('0x', ''),\n          crypto: {\n            ciphertext: ciphertext.toString('hex'),\n            cipherparams: {\n              iv: iv.toString('hex')\n            },\n            cipher: options.cipher || 'aes-128-ctr',\n            kdf: kdf,\n            kdfparams: kdfparams,\n            mac: mac.toString('hex')\n          }\n        };\n      }\n    }]);\n\n    return Accounts;\n  }(web3Core.AbstractWeb3Module);\n\n  var Wallet = function () {\n    function Wallet(accounts) {\n      _classCallCheck(this, Wallet);\n\n      this._accounts = accounts;\n      this.length = 0;\n      this.defaultKeyName = 'web3js_wallet';\n    }\n\n    _createClass(Wallet, [{\n      key: \"_findSafeIndex\",\n      value: function _findSafeIndex() {\n        var pointer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n        if (has(this, pointer)) {\n          return this._findSafeIndex(pointer + 1);\n        } else {\n          return pointer;\n        }\n      }\n    }, {\n      key: \"_currentIndexes\",\n      value: function _currentIndexes() {\n        var keys = Object.keys(this);\n        var indexes = keys.map(function (key) {\n          return parseInt(key);\n        }).filter(function (n) {\n          return n < 9e20;\n        });\n        return indexes;\n      }\n    }, {\n      key: \"create\",\n      value: function create(numberOfAccounts, entropy) {\n        for (var i = 0; i < numberOfAccounts; ++i) {\n          this.add(this._accounts.create(entropy).privateKey);\n        }\n\n        return this;\n      }\n    }, {\n      key: \"add\",\n      value: function add(account) {\n        if (isString(account)) {\n          account = this._accounts.privateKeyToAccount(account);\n        }\n\n        if (!this[account.address]) {\n          account = this._accounts.privateKeyToAccount(account.privateKey);\n          account.index = this._findSafeIndex();\n          this[account.index] = account;\n          this[account.address] = account;\n          this[account.address.toLowerCase()] = account;\n          this.length++;\n          return account;\n        } else {\n          return this[account.address];\n        }\n      }\n    }, {\n      key: \"remove\",\n      value: function remove(addressOrIndex) {\n        var account = this[addressOrIndex];\n\n        if (account && account.address) {\n          this[account.address].privateKey = null;\n          delete this[account.address];\n          this[account.address.toLowerCase()].privateKey = null;\n          delete this[account.address.toLowerCase()];\n          this[account.index].privateKey = null;\n          delete this[account.index];\n          this.length--;\n          return true;\n        } else {\n          return false;\n        }\n      }\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        var _this = this;\n\n        var indexes = this._currentIndexes();\n\n        indexes.forEach(function (index) {\n          _this.remove(index);\n        });\n        return this;\n      }\n    }, {\n      key: \"encrypt\",\n      value: function encrypt(password, options) {\n        var _this = this;\n\n        var indexes = this._currentIndexes();\n\n        var accounts = indexes.map(function (index) {\n          return _this[index].encrypt(password, options);\n        });\n        return accounts;\n      }\n    }, {\n      key: \"decrypt\",\n      value: function decrypt(encryptedWallet, password) {\n        var _this = this;\n\n        encryptedWallet.forEach(function (keystore) {\n          var account = _this._accounts.decrypt(keystore, password);\n\n          if (account) {\n            _this.add(account);\n          } else {\n            throw new Error(\"Couldn't decrypt accounts. Password wrong?\");\n          }\n        });\n        return this;\n      }\n    }, {\n      key: \"save\",\n      value: function save(password, keyName) {\n        try {\n          localStorage.setItem(keyName || this.defaultKeyName, JSON.stringify(this.encrypt(password)));\n        } catch (error) {\n          if (error.code === 18) {\n            return true;\n          } else {\n            throw new Error(error);\n          }\n        }\n\n        return true;\n      }\n    }, {\n      key: \"load\",\n      value: function load(password, keyName) {\n        var keystore;\n\n        try {\n          keystore = localStorage.getItem(keyName || this.defaultKeyName);\n\n          if (keystore) {\n            try {\n              keystore = JSON.parse(keystore);\n            } catch (error) {}\n          }\n        } catch (error) {\n          if (error.code === 18) {\n            keystore = this.defaultKeyName;\n          } else {\n            throw new Error(error);\n          }\n        }\n\n        return this.decrypt(keystore || [], password);\n      }\n    }]);\n\n    return Wallet;\n  }();\n\n  try {\n    if (typeof localStorage === 'undefined') {\n      delete Wallet.prototype.save;\n      delete Wallet.prototype.load;\n    }\n  } catch (error) {\n    if (error.code !== 18) {\n      throw new Error(error);\n    }\n  }\n\n  var AccountsModuleFactory = function () {\n    function AccountsModuleFactory(utils, formatters) {\n      _classCallCheck(this, AccountsModuleFactory);\n\n      this.utils = utils;\n      this.formatters = formatters;\n    }\n\n    _createClass(AccountsModuleFactory, [{\n      key: \"createAccounts\",\n      value: function createAccounts(provider, providersModuleFactory, methodModuleFactory, options) {\n        return new Accounts(provider, providersModuleFactory, methodModuleFactory, this.createMethodFactory(methodModuleFactory), this.utils, this.formatters, options);\n      }\n    }, {\n      key: \"createMethodFactory\",\n      value: function createMethodFactory(methodModuleFactory) {\n        return new MethodFactory(methodModuleFactory, this.utils, this.formatters);\n      }\n    }]);\n\n    return AccountsModuleFactory;\n  }();\n\n  var Accounts$1 = function Accounts(provider, options) {\n    return new AccountsModuleFactory(Utils, web3CoreHelpers.formatters).createAccounts(provider, new web3Providers.ProvidersModuleFactory(), new web3CoreMethod.MethodModuleFactory(), options);\n  };\n\n  exports.Accounts = Accounts$1;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}