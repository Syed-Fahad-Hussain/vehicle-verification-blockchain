{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('web3-core-promievent'), require('web3-providers'), require('web3-utils'), require('web3-core-helpers'), require('web3-core-method'), require('web3-eth-abi'), require('web3-net'), require('web3-core'), require('@babel/runtime/regenerator'), require('@babel/runtime/helpers/asyncToGenerator'), require('@babel/runtime/helpers/classCallCheck'), require('@babel/runtime/helpers/createClass'), require('@babel/runtime/helpers/possibleConstructorReturn'), require('@babel/runtime/helpers/getPrototypeOf'), require('@babel/runtime/helpers/get'), require('@babel/runtime/helpers/inherits'), require('lodash/isFunction'), require('eth-ens-namehash'), require('web3-eth-contract')) : typeof define === 'function' && define.amd ? define(['exports', 'web3-core-promievent', 'web3-providers', 'web3-utils', 'web3-core-helpers', 'web3-core-method', 'web3-eth-abi', 'web3-net', 'web3-core', '@babel/runtime/regenerator', '@babel/runtime/helpers/asyncToGenerator', '@babel/runtime/helpers/classCallCheck', '@babel/runtime/helpers/createClass', '@babel/runtime/helpers/possibleConstructorReturn', '@babel/runtime/helpers/getPrototypeOf', '@babel/runtime/helpers/get', '@babel/runtime/helpers/inherits', 'lodash/isFunction', 'eth-ens-namehash', 'web3-eth-contract'], factory) : factory(global.Web3EthEns = {}, global['web3-core-promievent'], global.web3Providers, global.Utils, global.web3CoreHelpers, global.web3CoreMethod, global.web3EthAbi, global.web3Net, global.web3Core, global._regeneratorRuntime, global._asyncToGenerator, global._classCallCheck, global._createClass, global._possibleConstructorReturn, global._getPrototypeOf, global._get, global._inherits, global.isFunction, global['eth-ens-namehash'], global['web3-eth-contract']);\n})(this, function (exports, web3CorePromievent, web3Providers, Utils, web3CoreHelpers, web3CoreMethod, web3EthAbi, web3Net, web3Core, _regeneratorRuntime, _asyncToGenerator, _classCallCheck, _createClass, _possibleConstructorReturn, _getPrototypeOf, _get, _inherits, isFunction, namehash, web3EthContract) {\n  'use strict';\n\n  _regeneratorRuntime = _regeneratorRuntime && _regeneratorRuntime.hasOwnProperty('default') ? _regeneratorRuntime['default'] : _regeneratorRuntime;\n  _asyncToGenerator = _asyncToGenerator && _asyncToGenerator.hasOwnProperty('default') ? _asyncToGenerator['default'] : _asyncToGenerator;\n  _classCallCheck = _classCallCheck && _classCallCheck.hasOwnProperty('default') ? _classCallCheck['default'] : _classCallCheck;\n  _createClass = _createClass && _createClass.hasOwnProperty('default') ? _createClass['default'] : _createClass;\n  _possibleConstructorReturn = _possibleConstructorReturn && _possibleConstructorReturn.hasOwnProperty('default') ? _possibleConstructorReturn['default'] : _possibleConstructorReturn;\n  _getPrototypeOf = _getPrototypeOf && _getPrototypeOf.hasOwnProperty('default') ? _getPrototypeOf['default'] : _getPrototypeOf;\n  _get = _get && _get.hasOwnProperty('default') ? _get['default'] : _get;\n  _inherits = _inherits && _inherits.hasOwnProperty('default') ? _inherits['default'] : _inherits;\n  isFunction = isFunction && isFunction.hasOwnProperty('default') ? isFunction['default'] : isFunction;\n  namehash = namehash && namehash.hasOwnProperty('default') ? namehash['default'] : namehash;\n\n  var Ens = function (_AbstractWeb3Module) {\n    _inherits(Ens, _AbstractWeb3Module);\n\n    function Ens(provider, providersModuleFactory, methodModuleFactory, options, ensModuleFactory, promiEvent, abiCoder, utils, formatters, registryOptions, net) {\n      var _this;\n\n      _classCallCheck(this, Ens);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(Ens).call(this, provider, providersModuleFactory, methodModuleFactory, null, options));\n      _this.ensModuleFactory = ensModuleFactory;\n      _this.promiEvent = promiEvent;\n      _this.abiCoder = abiCoder;\n      _this.utils = utils;\n      _this.formatters = formatters;\n      _this.registryOptions = registryOptions;\n      _this.net = net;\n      _this._registry = false;\n      return _this;\n    }\n\n    _createClass(Ens, [{\n      key: \"setProvider\",\n      value: function setProvider(provider, net) {\n        return !!(_get(_getPrototypeOf(Ens.prototype), \"setProvider\", this).call(this, provider, net) && this.registry.setProvider(provider, net));\n      }\n    }, {\n      key: \"resolver\",\n      value: function resolver(name) {\n        return this.registry.resolver(name);\n      }\n    }, {\n      key: \"supportsInterface\",\n      value: function () {\n        var _supportsInterface = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(name, interfaceId) {\n          var callback,\n              resolver,\n              _args = arguments;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  callback = _args.length > 2 && _args[2] !== undefined ? _args[2] : null;\n                  _context.next = 3;\n                  return this.registry.resolver(name);\n\n                case 3:\n                  resolver = _context.sent;\n                  return _context.abrupt(\"return\", resolver.methods.supportsInterface(interfaceId).call(callback));\n\n                case 5:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n\n        return function supportsInterface(_x, _x2) {\n          return _supportsInterface.apply(this, arguments);\n        };\n      }()\n    }, {\n      key: \"getAddress\",\n      value: function () {\n        var _getAddress = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(name) {\n          var callback,\n              resolver,\n              _args2 = arguments;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  callback = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : null;\n                  _context2.next = 3;\n                  return this.registry.resolver(name);\n\n                case 3:\n                  resolver = _context2.sent;\n                  return _context2.abrupt(\"return\", resolver.methods.addr(namehash.hash(name)).call(callback));\n\n                case 5:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this);\n        }));\n\n        return function getAddress(_x3) {\n          return _getAddress.apply(this, arguments);\n        };\n      }()\n    }, {\n      key: \"setAddress\",\n      value: function setAddress(name, address, sendOptions) {\n        var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n        var promiEvent = new this.registry.PromiEvent();\n        this.registry.resolver(name).then(function (resolver) {\n          resolver.methods.setAddr(namehash.hash(name), address).send(sendOptions, callback).on('transactionHash', function (transactionHash) {\n            promiEvent.emit('transactionHash', transactionHash);\n          }).on('confirmation', function (confirmationNumber, receipt) {\n            promiEvent.emit('confirmation', confirmationNumber, receipt);\n          }).on('receipt', function (receipt) {\n            if (isFunction(callback)) {\n              callback(receipt);\n            }\n\n            promiEvent.emit('receipt', receipt);\n            promiEvent.resolve(receipt);\n          }).on('error', function (error) {\n            if (isFunction(callback)) {\n              callback(error);\n            }\n\n            promiEvent.emit('error', error);\n            promiEvent.reject(error);\n          });\n        });\n        return promiEvent;\n      }\n    }, {\n      key: \"getPubkey\",\n      value: function () {\n        var _getPubkey = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3(name) {\n          var callback,\n              resolver,\n              _args3 = arguments;\n          return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  callback = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : null;\n                  _context3.next = 3;\n                  return this.registry.resolver(name);\n\n                case 3:\n                  resolver = _context3.sent;\n                  return _context3.abrupt(\"return\", resolver.methods.pubkey(namehash.hash(name)).call(callback));\n\n                case 5:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, this);\n        }));\n\n        return function getPubkey(_x4) {\n          return _getPubkey.apply(this, arguments);\n        };\n      }()\n    }, {\n      key: \"setPubkey\",\n      value: function setPubkey(name, x, y, sendOptions) {\n        var callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n        var promiEvent = new this.registry.PromiEvent();\n        this.registry.resolver(name).then(function (resolver) {\n          resolver.methods.setPubkey(namehash.hash(name), x, y).send(sendOptions, callback).on('transactionHash', function (transactionHash) {\n            promiEvent.emit('transactionHash', transactionHash);\n          }).on('confirmation', function (confirmationNumber, receipt) {\n            promiEvent.emit('confirmation', confirmationNumber, receipt);\n          }).on('receipt', function (receipt) {\n            if (isFunction(callback)) {\n              callback(receipt);\n            }\n\n            promiEvent.emit('receipt', receipt);\n            promiEvent.resolve(receipt);\n          }).on('error', function (error) {\n            if (isFunction(callback)) {\n              callback(error);\n            }\n\n            promiEvent.emit('error', error);\n            promiEvent.reject(error);\n          });\n        });\n        return promiEvent;\n      }\n    }, {\n      key: \"getText\",\n      value: function () {\n        var _getText = _asyncToGenerator(_regeneratorRuntime.mark(function _callee4(name, key) {\n          var callback,\n              resolver,\n              _args4 = arguments;\n          return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  callback = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : null;\n                  _context4.next = 3;\n                  return this.registry.resolver(name);\n\n                case 3:\n                  resolver = _context4.sent;\n                  return _context4.abrupt(\"return\", resolver.methods.text(namehash.hash(name), key).call(callback));\n\n                case 5:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4, this);\n        }));\n\n        return function getText(_x5, _x6) {\n          return _getText.apply(this, arguments);\n        };\n      }()\n    }, {\n      key: \"setText\",\n      value: function setText(name, key, value, sendOptions) {\n        var callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n        var promiEvent = new this.registry.PromiEvent();\n        this.registry.resolver(name).then(function (resolver) {\n          resolver.methods.setText(namehash.hash(name), key, value).send(sendOptions, callback).on('transactionHash', function (transactionHash) {\n            promiEvent.emit('transactionHash', transactionHash);\n          }).on('confirmation', function (confirmationNumber, receipt) {\n            promiEvent.emit('confirmation', confirmationNumber, receipt);\n          }).on('receipt', function (receipt) {\n            if (isFunction(callback)) {\n              callback(receipt);\n            }\n\n            promiEvent.emit('receipt', receipt);\n            promiEvent.resolve(receipt);\n          }).on('error', function (error) {\n            if (isFunction(callback)) {\n              callback(error);\n            }\n\n            promiEvent.emit('error', error);\n            promiEvent.reject(error);\n          });\n        });\n        return promiEvent;\n      }\n    }, {\n      key: \"getContent\",\n      value: function () {\n        var _getContent = _asyncToGenerator(_regeneratorRuntime.mark(function _callee5(name) {\n          var callback,\n              resolver,\n              _args5 = arguments;\n          return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n            while (1) {\n              switch (_context5.prev = _context5.next) {\n                case 0:\n                  callback = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : null;\n                  _context5.next = 3;\n                  return this.registry.resolver(name);\n\n                case 3:\n                  resolver = _context5.sent;\n                  return _context5.abrupt(\"return\", resolver.methods.content(namehash.hash(name)).call(callback));\n\n                case 5:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }\n          }, _callee5, this);\n        }));\n\n        return function getContent(_x7) {\n          return _getContent.apply(this, arguments);\n        };\n      }()\n    }, {\n      key: \"setContent\",\n      value: function setContent(name, hash, sendOptions) {\n        var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n        var promiEvent = new this.registry.PromiEvent();\n        this.registry.resolver(name).then(function (resolver) {\n          resolver.methods.setContent(namehash.hash(name), hash).send(sendOptions, callback).on('transactionHash', function (transactionHash) {\n            promiEvent.emit('transactionHash', transactionHash);\n          }).on('confirmation', function (confirmationNumber, receipt) {\n            promiEvent.emit('confirmation', confirmationNumber, receipt);\n          }).on('receipt', function (receipt) {\n            if (isFunction(callback)) {\n              callback(receipt);\n            }\n\n            promiEvent.emit('receipt', receipt);\n            promiEvent.resolve(receipt);\n          }).on('error', function (error) {\n            if (isFunction(callback)) {\n              callback(error);\n            }\n\n            promiEvent.emit('error', error);\n            promiEvent.reject(error);\n          });\n        });\n        return promiEvent;\n      }\n    }, {\n      key: \"getMultihash\",\n      value: function () {\n        var _getMultihash = _asyncToGenerator(_regeneratorRuntime.mark(function _callee6(name) {\n          var callback,\n              resolver,\n              _args6 = arguments;\n          return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n            while (1) {\n              switch (_context6.prev = _context6.next) {\n                case 0:\n                  callback = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : null;\n                  _context6.next = 3;\n                  return this.registry.resolver(name);\n\n                case 3:\n                  resolver = _context6.sent;\n                  return _context6.abrupt(\"return\", resolver.methods.multihash(namehash.hash(name)).call(callback));\n\n                case 5:\n                case \"end\":\n                  return _context6.stop();\n              }\n            }\n          }, _callee6, this);\n        }));\n\n        return function getMultihash(_x8) {\n          return _getMultihash.apply(this, arguments);\n        };\n      }()\n    }, {\n      key: \"setMultihash\",\n      value: function setMultihash(name, hash, sendOptions) {\n        var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n        var promiEvent = new this.registry.PromiEvent();\n        this.registry.resolver(name).then(function (resolver) {\n          resolver.methods.setMultihash(namehash.hash(name), hash).send(sendOptions, callback).on('transactionHash', function (transactionHash) {\n            promiEvent.emit('transactionHash', transactionHash);\n          }).on('confirmation', function (confirmationNumber, receipt) {\n            promiEvent.emit('confirmation', confirmationNumber, receipt);\n          }).on('receipt', function (receipt) {\n            if (isFunction(callback)) {\n              callback(receipt);\n            }\n\n            promiEvent.emit('receipt', receipt);\n            promiEvent.resolve(receipt);\n          }).on('error', function (error) {\n            if (isFunction(callback)) {\n              callback(error);\n            }\n\n            promiEvent.emit('error', error);\n            promiEvent.reject(error);\n          });\n        });\n        return promiEvent;\n      }\n    }, {\n      key: \"getContenthash\",\n      value: function () {\n        var _getContenthash = _asyncToGenerator(_regeneratorRuntime.mark(function _callee7(name) {\n          var callback,\n              resolver,\n              _args7 = arguments;\n          return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n            while (1) {\n              switch (_context7.prev = _context7.next) {\n                case 0:\n                  callback = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : null;\n                  _context7.next = 3;\n                  return this.registry.resolver(name);\n\n                case 3:\n                  resolver = _context7.sent;\n                  return _context7.abrupt(\"return\", resolver.methods.contenthash(namehash.hash(name)).call(callback));\n\n                case 5:\n                case \"end\":\n                  return _context7.stop();\n              }\n            }\n          }, _callee7, this);\n        }));\n\n        return function getContenthash(_x9) {\n          return _getContenthash.apply(this, arguments);\n        };\n      }()\n    }, {\n      key: \"setContenthash\",\n      value: function setContenthash(name, hash, sendOptions) {\n        var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n        var promiEvent = new this.registry.PromiEvent();\n        this.registry.resolver(name).then(function (resolver) {\n          resolver.methods.setContenthash(namehash.hash(name), hash).send(sendOptions, callback).on('transactionHash', function (transactionHash) {\n            promiEvent.emit('transactionHash', transactionHash);\n          }).on('confirmation', function (confirmationNumber, receipt) {\n            promiEvent.emit('confirmation', confirmationNumber, receipt);\n          }).on('receipt', function (receipt) {\n            if (isFunction(callback)) {\n              callback(receipt);\n            }\n\n            promiEvent.emit('receipt', receipt);\n            promiEvent.resolve(receipt);\n          }).on('error', function (error) {\n            if (isFunction(callback)) {\n              callback(error);\n            }\n\n            promiEvent.emit('error', error);\n            promiEvent.reject(error);\n          });\n        });\n        return promiEvent;\n      }\n    }, {\n      key: \"registry\",\n      get: function get() {\n        if (!this._registry) {\n          this._registry = this.ensModuleFactory.createRegistry(this.currentProvider, this.providersModuleFactory, this.methodModuleFactory, this.contractModuleFactory, this.promiEvent, this.abiCoder, this.utils, this.formatters, this.registryOptions, this.net);\n        }\n\n        return this._registry;\n      }\n    }]);\n\n    return Ens;\n  }(web3Core.AbstractWeb3Module);\n\n  var REGISTRY_ABI = [{\n    constant: true,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }],\n    name: 'resolver',\n    outputs: [{\n      name: '',\n      type: 'address'\n    }],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: true,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }],\n    name: 'owner',\n    outputs: [{\n      name: '',\n      type: 'address'\n    }],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: false,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      name: 'label',\n      type: 'bytes32'\n    }, {\n      name: 'owner',\n      type: 'address'\n    }],\n    name: 'setSubnodeOwner',\n    outputs: [],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: false,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      name: 'ttl',\n      type: 'uint64'\n    }],\n    name: 'setTTL',\n    outputs: [],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: true,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }],\n    name: 'ttl',\n    outputs: [{\n      name: '',\n      type: 'uint64'\n    }],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: false,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      name: 'resolver',\n      type: 'address'\n    }],\n    name: 'setResolver',\n    outputs: [],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: false,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      name: 'owner',\n      type: 'address'\n    }],\n    name: 'setOwner',\n    outputs: [],\n    payable: false,\n    type: 'function'\n  }, {\n    anonymous: false,\n    inputs: [{\n      indexed: true,\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      indexed: false,\n      name: 'owner',\n      type: 'address'\n    }],\n    name: 'Transfer',\n    type: 'event'\n  }, {\n    anonymous: false,\n    inputs: [{\n      indexed: true,\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      indexed: true,\n      name: 'label',\n      type: 'bytes32'\n    }, {\n      indexed: false,\n      name: 'owner',\n      type: 'address'\n    }],\n    name: 'NewOwner',\n    type: 'event'\n  }, {\n    anonymous: false,\n    inputs: [{\n      indexed: true,\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      indexed: false,\n      name: 'resolver',\n      type: 'address'\n    }],\n    name: 'NewResolver',\n    type: 'event'\n  }, {\n    anonymous: false,\n    inputs: [{\n      indexed: true,\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      indexed: false,\n      name: 'ttl',\n      type: 'uint64'\n    }],\n    name: 'NewTTL',\n    type: 'event'\n  }];\n  var RESOLVER_ABI = [{\n    constant: true,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      name: 'key',\n      type: 'string'\n    }],\n    name: 'text',\n    outputs: [{\n      name: '',\n      type: 'string'\n    }],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  }, {\n    constant: false,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      name: 'key',\n      type: 'string'\n    }, {\n      name: 'value',\n      type: 'string'\n    }],\n    name: 'setText',\n    outputs: [],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  }, {\n    constant: true,\n    inputs: [{\n      name: 'interfaceID',\n      type: 'bytes4'\n    }],\n    name: 'supportsInterface',\n    outputs: [{\n      name: '',\n      type: 'bool'\n    }],\n    payable: false,\n    stateMutability: 'pure',\n    type: 'function'\n  }, {\n    constant: true,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      name: 'contentTypes',\n      type: 'uint256'\n    }],\n    name: 'ABI',\n    outputs: [{\n      name: 'contentType',\n      type: 'uint256'\n    }, {\n      name: 'data',\n      type: 'bytes'\n    }],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: false,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      name: 'hash',\n      type: 'bytes'\n    }],\n    name: 'setMultihash',\n    outputs: [],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  }, {\n    constant: true,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }],\n    name: 'multihash',\n    outputs: [{\n      name: '',\n      type: 'bytes'\n    }],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  }, {\n    constant: false,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      name: 'hash',\n      type: 'bytes'\n    }],\n    name: 'setContenthash',\n    outputs: [],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  }, {\n    constant: true,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }],\n    name: 'contenthash',\n    outputs: [{\n      name: '',\n      type: 'bytes'\n    }],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  }, {\n    constant: false,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      name: 'x',\n      type: 'bytes32'\n    }, {\n      name: 'y',\n      type: 'bytes32'\n    }],\n    name: 'setPubkey',\n    outputs: [],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: true,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }],\n    name: 'content',\n    outputs: [{\n      name: 'ret',\n      type: 'bytes32'\n    }],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: true,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }],\n    name: 'addr',\n    outputs: [{\n      name: 'ret',\n      type: 'address'\n    }],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: false,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      name: 'contentType',\n      type: 'uint256'\n    }, {\n      name: 'data',\n      type: 'bytes'\n    }],\n    name: 'setABI',\n    outputs: [],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: true,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }],\n    name: 'name',\n    outputs: [{\n      name: 'ret',\n      type: 'string'\n    }],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: false,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      name: 'name',\n      type: 'string'\n    }],\n    name: 'setName',\n    outputs: [],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: false,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      name: 'hash',\n      type: 'bytes32'\n    }],\n    name: 'setContent',\n    outputs: [],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: true,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }],\n    name: 'pubkey',\n    outputs: [{\n      name: 'x',\n      type: 'bytes32'\n    }, {\n      name: 'y',\n      type: 'bytes32'\n    }],\n    payable: false,\n    type: 'function'\n  }, {\n    constant: false,\n    inputs: [{\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      name: 'addr',\n      type: 'address'\n    }],\n    name: 'setAddr',\n    outputs: [],\n    payable: false,\n    type: 'function'\n  }, {\n    inputs: [{\n      name: 'ensAddr',\n      type: 'address'\n    }],\n    payable: false,\n    type: 'constructor'\n  }, {\n    anonymous: false,\n    inputs: [{\n      indexed: true,\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      indexed: false,\n      name: 'a',\n      type: 'address'\n    }],\n    name: 'AddrChanged',\n    type: 'event'\n  }, {\n    anonymous: false,\n    inputs: [{\n      indexed: true,\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      indexed: false,\n      name: 'hash',\n      type: 'bytes32'\n    }],\n    name: 'ContentChanged',\n    type: 'event'\n  }, {\n    anonymous: false,\n    inputs: [{\n      indexed: true,\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      indexed: false,\n      name: 'indexedKey',\n      type: 'string'\n    }, {\n      indexed: false,\n      name: 'key',\n      type: 'string'\n    }],\n    name: 'TextChanged',\n    type: 'event'\n  }, {\n    anonymous: false,\n    inputs: [{\n      indexed: true,\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      indexed: false,\n      name: 'hash',\n      type: 'bytes'\n    }],\n    name: 'ContenthashChanged',\n    type: 'event'\n  }, {\n    anonymous: false,\n    inputs: [{\n      indexed: true,\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      indexed: false,\n      name: 'name',\n      type: 'string'\n    }],\n    name: 'NameChanged',\n    type: 'event'\n  }, {\n    anonymous: false,\n    inputs: [{\n      indexed: true,\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      indexed: true,\n      name: 'contentType',\n      type: 'uint256'\n    }],\n    name: 'ABIChanged',\n    type: 'event'\n  }, {\n    anonymous: false,\n    inputs: [{\n      indexed: true,\n      name: 'node',\n      type: 'bytes32'\n    }, {\n      indexed: false,\n      name: 'x',\n      type: 'bytes32'\n    }, {\n      indexed: false,\n      name: 'y',\n      type: 'bytes32'\n    }],\n    name: 'PubkeyChanged',\n    type: 'event'\n  }];\n\n  var Registry = function (_AbstractContract) {\n    _inherits(Registry, _AbstractContract);\n\n    function Registry(provider, providersModuleFactory, methodModuleFactory, contractModuleFactory, promiEvent, abiCoder, utils, formatters, options, net) {\n      var _this;\n\n      _classCallCheck(this, Registry);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(Registry).call(this, provider, providersModuleFactory, methodModuleFactory, contractModuleFactory, promiEvent, abiCoder, utils, formatters, REGISTRY_ABI, '', options));\n      _this.net = net;\n      _this.resolverContract = null;\n      _this.resolverName = null;\n\n      _this.checkNetwork().then(function (address) {\n        _this.address = address;\n      });\n\n      return _this;\n    }\n\n    _createClass(Registry, [{\n      key: \"owner\",\n      value: function owner(name) {\n        var _this2 = this;\n\n        var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        return new Promise(function (resolve, reject) {\n          _this2.methods.owner(namehash.hash(name)).call().then(function (receipt) {\n            resolve(receipt);\n\n            if (isFunction(callback)) {\n              callback(false, receipt);\n            }\n          }).catch(function (error) {\n            reject(error);\n\n            if (isFunction(callback)) {\n              callback(error, null);\n            }\n          });\n        });\n      }\n    }, {\n      key: \"setProvider\",\n      value: function setProvider(provider, net) {\n        if (this.resolverContract) {\n          return !!(_get(_getPrototypeOf(Registry.prototype), \"setProvider\", this).call(this, provider, net) && this.resolverContract.setProvider(provider, net));\n        }\n\n        return _get(_getPrototypeOf(Registry.prototype), \"setProvider\", this).call(this, provider, net);\n      }\n    }, {\n      key: \"resolver\",\n      value: function () {\n        var _resolver = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(name) {\n          var address, clone;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  if (!(this.resolverName === name && this.resolverContract)) {\n                    _context.next = 2;\n                    break;\n                  }\n\n                  return _context.abrupt(\"return\", this.resolverContract);\n\n                case 2:\n                  _context.next = 4;\n                  return this.methods.resolver(namehash.hash(name)).call();\n\n                case 4:\n                  address = _context.sent;\n                  clone = this.clone();\n                  clone.jsonInterface = RESOLVER_ABI;\n                  clone.address = address;\n                  this.resolverName = name;\n                  this.resolverContract = clone;\n                  return _context.abrupt(\"return\", clone);\n\n                case 11:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n\n        return function resolver(_x) {\n          return _resolver.apply(this, arguments);\n        };\n      }()\n    }, {\n      key: \"checkNetwork\",\n      value: function () {\n        var _checkNetwork = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2() {\n          var ensAddresses, block, headAge, networkType, address;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  ensAddresses = {\n                    main: '0x314159265dD8dbb310642f98f50C066173C1259b',\n                    ropsten: '0x112234455c3a32fd11230c42e7bccd4a84e02010',\n                    rinkeby: '0xe7410170f87102df0055eb195163a03b7f2bff4a'\n                  };\n                  _context2.next = 3;\n                  return this.net.getBlock('latest', false);\n\n                case 3:\n                  block = _context2.sent;\n                  headAge = new Date() / 1000 - block.timestamp;\n\n                  if (!(headAge > 3600)) {\n                    _context2.next = 7;\n                    break;\n                  }\n\n                  throw new Error(\"Network not synced; last block was \".concat(headAge, \" seconds ago\"));\n\n                case 7:\n                  _context2.next = 9;\n                  return this.net.getNetworkType();\n\n                case 9:\n                  networkType = _context2.sent;\n                  address = ensAddresses[networkType];\n\n                  if (!(typeof address === 'undefined')) {\n                    _context2.next = 13;\n                    break;\n                  }\n\n                  throw new TypeError(\"ENS is not supported on network: \\\"\".concat(networkType, \"\\\"\"));\n\n                case 13:\n                  return _context2.abrupt(\"return\", address);\n\n                case 14:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this);\n        }));\n\n        return function checkNetwork() {\n          return _checkNetwork.apply(this, arguments);\n        };\n      }()\n    }]);\n\n    return Registry;\n  }(web3EthContract.AbstractContract);\n\n  var EnsModuleFactory = function () {\n    function EnsModuleFactory() {\n      _classCallCheck(this, EnsModuleFactory);\n    }\n\n    _createClass(EnsModuleFactory, [{\n      key: \"createENS\",\n      value: function createENS(provider, providersModuleFactory, methodModuleFactory, contractModuleFactory, promiEvent, abiCoder, utils, formatters, net, registryOptions, ensModuleOptions) {\n        return new Ens(provider, providersModuleFactory, methodModuleFactory, ensModuleOptions, this, promiEvent, abiCoder, utils, formatters, registryOptions, net);\n      }\n    }, {\n      key: \"createRegistry\",\n      value: function createRegistry(provider, providersModuleFactory, methodModuleFactory, contractModuleFactory, promiEvent, abiCoder, utils, formatters, options, net) {\n        return new Registry(provider, providersModuleFactory, methodModuleFactory, contractModuleFactory, promiEvent, abiCoder, utils, formatters, options, net);\n      }\n    }]);\n\n    return EnsModuleFactory;\n  }();\n\n  var Ens$1 = function Ens(provider, accounts, options) {\n    var abiCoder = new web3EthAbi.AbiCoder();\n    var methodModuleFactory = new web3CoreMethod.MethodModuleFactory();\n    return new EnsModuleFactory().createENS(provider, new web3Providers.ProvidersModuleFactory(), new web3CoreMethod.MethodModuleFactory(accounts), new web3EthContract.ContractModuleFactory(Utils, web3CoreHelpers.formatters, abiCoder, accounts, methodModuleFactory), web3CorePromievent.PromiEvent, abiCoder, Utils, web3CoreHelpers.formatters, new web3Net.Network(provider), {}, options);\n  };\n\n  exports.Ens = Ens$1;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}