{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('web3-providers'), require('eventemitter3'), require('@babel/runtime/regenerator'), require('@babel/runtime/helpers/asyncToGenerator'), require('@babel/runtime/helpers/toConsumableArray'), require('lodash/isString'), require('lodash/cloneDeep'), require('web3-core-promievent'), require('web3-core-subscriptions'), require('web3-core-helpers'), require('web3-utils'), require('lodash/isObject'), require('@babel/runtime/helpers/get'), require('lodash/isFunction'), require('@babel/runtime/helpers/createClass'), require('@babel/runtime/helpers/classCallCheck'), require('@babel/runtime/helpers/possibleConstructorReturn'), require('@babel/runtime/helpers/getPrototypeOf'), require('@babel/runtime/helpers/inherits')) : typeof define === 'function' && define.amd ? define(['exports', 'web3-providers', 'eventemitter3', '@babel/runtime/regenerator', '@babel/runtime/helpers/asyncToGenerator', '@babel/runtime/helpers/toConsumableArray', 'lodash/isString', 'lodash/cloneDeep', 'web3-core-promievent', 'web3-core-subscriptions', 'web3-core-helpers', 'web3-utils', 'lodash/isObject', '@babel/runtime/helpers/get', 'lodash/isFunction', '@babel/runtime/helpers/createClass', '@babel/runtime/helpers/classCallCheck', '@babel/runtime/helpers/possibleConstructorReturn', '@babel/runtime/helpers/getPrototypeOf', '@babel/runtime/helpers/inherits'], factory) : factory(global.Web3CoreMethod = {}, global.web3Providers, global.EventEmitter, global._regeneratorRuntime, global._asyncToGenerator, global._toConsumableArray, global.isString, global.cloneDeep, global.web3CorePromievent, global.web3CoreSubscriptions, global.web3CoreHelpers, global.Utils, global.isObject, global._get, global.isFunction, global._createClass, global._classCallCheck, global._possibleConstructorReturn, global._getPrototypeOf, global._inherits);\n})(this, function (exports, web3Providers, EventEmitter, _regeneratorRuntime, _asyncToGenerator, _toConsumableArray, isString, cloneDeep, web3CorePromievent, web3CoreSubscriptions, web3CoreHelpers, Utils, isObject, _get, isFunction, _createClass, _classCallCheck, _possibleConstructorReturn, _getPrototypeOf, _inherits) {\n  'use strict';\n\n  EventEmitter = EventEmitter && EventEmitter.hasOwnProperty('default') ? EventEmitter['default'] : EventEmitter;\n  _regeneratorRuntime = _regeneratorRuntime && _regeneratorRuntime.hasOwnProperty('default') ? _regeneratorRuntime['default'] : _regeneratorRuntime;\n  _asyncToGenerator = _asyncToGenerator && _asyncToGenerator.hasOwnProperty('default') ? _asyncToGenerator['default'] : _asyncToGenerator;\n  _toConsumableArray = _toConsumableArray && _toConsumableArray.hasOwnProperty('default') ? _toConsumableArray['default'] : _toConsumableArray;\n  isString = isString && isString.hasOwnProperty('default') ? isString['default'] : isString;\n  cloneDeep = cloneDeep && cloneDeep.hasOwnProperty('default') ? cloneDeep['default'] : cloneDeep;\n  isObject = isObject && isObject.hasOwnProperty('default') ? isObject['default'] : isObject;\n  _get = _get && _get.hasOwnProperty('default') ? _get['default'] : _get;\n  isFunction = isFunction && isFunction.hasOwnProperty('default') ? isFunction['default'] : isFunction;\n  _createClass = _createClass && _createClass.hasOwnProperty('default') ? _createClass['default'] : _createClass;\n  _classCallCheck = _classCallCheck && _classCallCheck.hasOwnProperty('default') ? _classCallCheck['default'] : _classCallCheck;\n  _possibleConstructorReturn = _possibleConstructorReturn && _possibleConstructorReturn.hasOwnProperty('default') ? _possibleConstructorReturn['default'] : _possibleConstructorReturn;\n  _getPrototypeOf = _getPrototypeOf && _getPrototypeOf.hasOwnProperty('default') ? _getPrototypeOf['default'] : _getPrototypeOf;\n  _inherits = _inherits && _inherits.hasOwnProperty('default') ? _inherits['default'] : _inherits;\n\n  var TransactionConfirmationWorkflow = function () {\n    function TransactionConfirmationWorkflow(transactionReceiptValidator, newHeadsWatcher, getTransactionReceiptMethod) {\n      _classCallCheck(this, TransactionConfirmationWorkflow);\n\n      this.transactionReceiptValidator = transactionReceiptValidator;\n      this.newHeadsWatcher = newHeadsWatcher;\n      this.timeoutCounter = 0;\n      this.confirmationsCounter = 0;\n      this.getTransactionReceiptMethod = getTransactionReceiptMethod;\n    }\n\n    _createClass(TransactionConfirmationWorkflow, [{\n      key: \"execute\",\n      value: function execute(method, moduleInstance, transactionHash, promiEvent) {\n        var _this = this;\n\n        this.getTransactionReceiptMethod.parameters = [transactionHash];\n        this.getTransactionReceiptMethod.execute(moduleInstance).then(function (receipt) {\n          if (receipt && receipt.blockHash) {\n            var validationResult = _this.transactionReceiptValidator.validate(receipt, method.parameters);\n\n            if (validationResult === true) {\n              _this.handleSuccessState(receipt, method, promiEvent);\n\n              return;\n            }\n\n            _this.handleErrorState(validationResult, method, promiEvent);\n\n            return;\n          }\n\n          _this.newHeadsWatcher.watch(moduleInstance).on('newHead', function () {\n            _this.timeoutCounter++;\n\n            if (!_this.isTimeoutTimeExceeded(moduleInstance, _this.newHeadsWatcher.isPolling)) {\n              _this.getTransactionReceiptMethod.execute(moduleInstance).then(function (receipt) {\n                var validationResult = _this.transactionReceiptValidator.validate(receipt, method.parameters);\n\n                if (validationResult === true) {\n                  _this.confirmationsCounter++;\n                  promiEvent.emit('confirmation', _this.confirmationsCounter, receipt);\n\n                  if (_this.isConfirmed(moduleInstance)) {\n                    _this.handleSuccessState(receipt, method, promiEvent);\n                  }\n\n                  return;\n                }\n\n                _this.handleErrorState(validationResult, method, promiEvent);\n              });\n\n              return;\n            }\n\n            var error = new Error(\"Transaction was not mined within \".concat(moduleInstance.transactionBlockTimeout, \" blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!\"));\n\n            if (_this.newHeadsWatcher.isPolling) {\n              error = new Error(\"Transaction was not mined within \".concat(moduleInstance.transactionPollingTimeout, \" seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!\"));\n            }\n\n            _this.handleErrorState(error, method, promiEvent);\n          });\n        });\n      }\n    }, {\n      key: \"isConfirmed\",\n      value: function isConfirmed(moduleInstance) {\n        return this.confirmationsCounter === moduleInstance.transactionConfirmationBlocks;\n      }\n    }, {\n      key: \"isTimeoutTimeExceeded\",\n      value: function isTimeoutTimeExceeded(moduleInstance, watcherIsPolling) {\n        var timeout = moduleInstance.transactionBlockTimeout;\n\n        if (watcherIsPolling) {\n          timeout = moduleInstance.transactionPollingTimeout;\n        }\n\n        return this.timeoutCounter > timeout;\n      }\n    }, {\n      key: \"handleSuccessState\",\n      value: function handleSuccessState(receipt, method, promiEvent) {\n        this.timeoutCounter = 0;\n        this.confirmationsCounter = 0;\n        this.newHeadsWatcher.stop();\n\n        if (method.constructor.name === 'ContractDeployMethod') {\n          if (method.callback) {\n            method.callback(false, receipt);\n          }\n\n          promiEvent.resolve(method.afterExecution(receipt));\n          promiEvent.emit('receipt', receipt);\n          promiEvent.removeAllListeners();\n          return;\n        }\n\n        var mappedReceipt = method.afterExecution(receipt);\n\n        if (method.callback) {\n          method.callback(false, mappedReceipt);\n        }\n\n        promiEvent.resolve(mappedReceipt);\n        promiEvent.emit('receipt', mappedReceipt);\n        promiEvent.removeAllListeners();\n      }\n    }, {\n      key: \"handleErrorState\",\n      value: function handleErrorState(error, method, promiEvent) {\n        this.timeoutCounter = 0;\n        this.confirmationsCounter = 0;\n        this.newHeadsWatcher.stop();\n\n        if (method.callback) {\n          method.callback(error, null);\n        }\n\n        promiEvent.reject(error);\n        promiEvent.emit('error', error);\n        promiEvent.removeAllListeners();\n      }\n    }]);\n\n    return TransactionConfirmationWorkflow;\n  }();\n\n  var TransactionReceiptValidator = function () {\n    function TransactionReceiptValidator() {\n      _classCallCheck(this, TransactionReceiptValidator);\n    }\n\n    _createClass(TransactionReceiptValidator, [{\n      key: \"validate\",\n      value: function validate(receipt, methodParameters) {\n        var receiptJSON = JSON.stringify(receipt, null, 2);\n\n        if (!this.isValidGasUsage(receipt, methodParameters)) {\n          return new Error(\"Transaction ran out of gas. Please provide more gas:\\n\".concat(receiptJSON));\n        }\n\n        if (!this.isValidReceiptStatus(receipt)) {\n          return new Error(\"Transaction has been reverted by the EVM:\\n\".concat(receiptJSON));\n        }\n\n        return true;\n      }\n    }, {\n      key: \"isValidReceiptStatus\",\n      value: function isValidReceiptStatus(receipt) {\n        return receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined';\n      }\n    }, {\n      key: \"isValidGasUsage\",\n      value: function isValidGasUsage(receipt, methodParameters) {\n        var gasProvided = null;\n\n        if (isObject(methodParameters[0]) && methodParameters[0].gas) {\n          gasProvided = methodParameters[0].gas;\n        }\n\n        return !receipt.outOfGas && (!gasProvided || gasProvided !== receipt.gasUsed);\n      }\n    }]);\n\n    return TransactionReceiptValidator;\n  }();\n\n  var NewHeadsWatcher = function (_EventEmitter) {\n    _inherits(NewHeadsWatcher, _EventEmitter);\n\n    function NewHeadsWatcher(subscriptionsFactory) {\n      var _this;\n\n      _classCallCheck(this, NewHeadsWatcher);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(NewHeadsWatcher).call(this));\n      _this.subscriptionsFactory = subscriptionsFactory;\n      _this.confirmationInterval = null;\n      _this.confirmationSubscription = null;\n      _this.isPolling = false;\n      return _this;\n    }\n\n    _createClass(NewHeadsWatcher, [{\n      key: \"watch\",\n      value: function watch(moduleInstance) {\n        var _this2 = this;\n\n        if (this.isSocketConnection(moduleInstance.currentProvider)) {\n          this.confirmationSubscription = this.subscriptionsFactory.createNewHeadsSubscription(moduleInstance).subscribe(function () {\n            _this2.emit('newHead');\n          });\n          return this;\n        }\n\n        this.isPolling = true;\n        this.confirmationInterval = setInterval(function () {\n          _this2.emit('newHead');\n        }, 1000);\n        return this;\n      }\n    }, {\n      key: \"stop\",\n      value: function stop() {\n        if (this.confirmationSubscription) {\n          this.confirmationSubscription.unsubscribe();\n        }\n\n        if (this.confirmationInterval) {\n          clearInterval(this.confirmationInterval);\n        }\n\n        this.removeAllListeners('newHead');\n      }\n    }, {\n      key: \"isSocketConnection\",\n      value: function isSocketConnection(provider) {\n        return provider instanceof web3Providers.WebsocketProvider || provider instanceof web3Providers.IpcProvider || provider instanceof web3Providers.EthereumProvider;\n      }\n    }]);\n\n    return NewHeadsWatcher;\n  }(EventEmitter);\n\n  var MethodProxy = function MethodProxy(target, methodFactory) {\n    _classCallCheck(this, MethodProxy);\n\n    return new Proxy(target, {\n      get: function get(target, name) {\n        if (methodFactory.hasMethod(name)) {\n          var anonymousFunction = function anonymousFunction() {\n            method.arguments = arguments;\n\n            if (method.Type === 'CALL') {\n              return method.execute(target);\n            }\n\n            return method.execute(target, new web3CorePromievent.PromiEvent());\n          };\n\n          if (typeof target[name] !== 'undefined') {\n            throw new TypeError(\"Duplicated method \".concat(name, \". This method is defined as RPC call and as Object method.\"));\n          }\n\n          var method = methodFactory.createMethod(name);\n          anonymousFunction.method = method;\n\n          anonymousFunction.request = function () {\n            method.arguments = arguments;\n            return method;\n          };\n\n          return anonymousFunction;\n        }\n\n        return target[name];\n      }\n    });\n  };\n\n  var AbstractSigner = function () {\n    function AbstractSigner(accounts) {\n      _classCallCheck(this, AbstractSigner);\n\n      this.accounts = accounts;\n    }\n\n    _createClass(AbstractSigner, [{\n      key: \"getWallet\",\n      value: function getWallet(from) {\n        var account = this.accounts.wallet[from];\n\n        if (account) {\n          return account;\n        }\n\n        return null;\n      }\n    }]);\n\n    return AbstractSigner;\n  }();\n\n  var MessageSigner = function (_AbstractSigner) {\n    _inherits(MessageSigner, _AbstractSigner);\n\n    function MessageSigner(accounts) {\n      _classCallCheck(this, MessageSigner);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(MessageSigner).call(this, accounts));\n    }\n\n    _createClass(MessageSigner, [{\n      key: \"sign\",\n      value: function sign(data, address) {\n        var wallet = this.getWallet(address);\n\n        if (wallet && wallet.privateKey) {\n          return this.accounts.sign(data, wallet.privateKey).signature;\n        }\n\n        throw new Error('Wallet or privateKey in wallet is not set!');\n      }\n    }]);\n\n    return MessageSigner;\n  }(AbstractSigner);\n\n  var TransactionSigner = function (_AbstractSigner) {\n    _inherits(TransactionSigner, _AbstractSigner);\n\n    function TransactionSigner(accounts) {\n      _classCallCheck(this, TransactionSigner);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(TransactionSigner).call(this, accounts));\n    }\n\n    _createClass(TransactionSigner, [{\n      key: \"sign\",\n      value: function () {\n        var _sign = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(transaction) {\n          var wallet;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  wallet = this.getWallet(transaction.from);\n\n                  if (!(wallet && wallet.privateKey)) {\n                    _context.next = 12;\n                    break;\n                  }\n\n                  delete transaction.from;\n                  _context.prev = 3;\n                  _context.next = 6;\n                  return this.accounts.signTransaction(transaction, wallet.privateKey);\n\n                case 6:\n                  return _context.abrupt(\"return\", _context.sent);\n\n                case 9:\n                  _context.prev = 9;\n                  _context.t0 = _context[\"catch\"](3);\n                  throw _context.t0;\n\n                case 12:\n                  throw new Error('Wallet or privateKey in wallet is not set!');\n\n                case 13:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this, [[3, 9]]);\n        }));\n\n        return function sign(_x) {\n          return _sign.apply(this, arguments);\n        };\n      }()\n    }]);\n\n    return TransactionSigner;\n  }(AbstractSigner);\n\n  var AbstractMethod = function () {\n    function AbstractMethod(rpcMethod, parametersAmount, utils, formatters) {\n      _classCallCheck(this, AbstractMethod);\n\n      this.utils = utils;\n      this.formatters = formatters;\n      this.promiEvent = new web3CorePromievent.PromiEvent();\n      this._arguments = {\n        parameters: []\n      };\n      this._rpcMethod = rpcMethod;\n      this._parametersAmount = parametersAmount;\n    }\n\n    _createClass(AbstractMethod, [{\n      key: \"beforeExecution\",\n      value: function beforeExecution(moduleInstance) {}\n    }, {\n      key: \"afterExecution\",\n      value: function afterExecution(response) {\n        return response;\n      }\n    }, {\n      key: \"execute\",\n      value: function execute(moduleInstance) {}\n    }, {\n      key: \"isHash\",\n      value: function isHash(parameter) {\n        return isString(parameter) && parameter.indexOf('0x') === 0;\n      }\n    }, {\n      key: \"hasWallets\",\n      value: function hasWallets() {\n        return this.accounts && this.accounts.wallet.length > 0;\n      }\n    }, {\n      key: \"rpcMethod\",\n      set: function set(value) {\n        this._rpcMethod = value;\n      },\n      get: function get() {\n        return this._rpcMethod;\n      }\n    }, {\n      key: \"parametersAmount\",\n      set: function set(value) {\n        this._parametersAmount = value;\n      },\n      get: function get() {\n        return this._parametersAmount;\n      }\n    }, {\n      key: \"parameters\",\n      get: function get() {\n        return this._arguments.parameters;\n      },\n      set: function set(value) {\n        this._arguments.parameters = value;\n      }\n    }, {\n      key: \"callback\",\n      get: function get() {\n        return this._arguments.callback;\n      },\n      set: function set(value) {\n        this._arguments.callback = value;\n      }\n    }, {\n      key: \"arguments\",\n      set: function set(args) {\n        var parameters = cloneDeep(_toConsumableArray(args));\n        var callback = null;\n\n        if (parameters.length > this.parametersAmount) {\n          if (!isFunction(parameters[parameters.length - 1])) {\n            throw new TypeError(\"The latest parameter should be a function otherwise it can't be used as callback\");\n          }\n\n          callback = parameters.pop();\n        }\n\n        this._arguments = {\n          callback: callback,\n          parameters: parameters\n        };\n      },\n      get: function get() {\n        return this._arguments;\n      }\n    }]);\n\n    return AbstractMethod;\n  }();\n\n  var AbstractCallMethod = function (_AbstractMethod) {\n    _inherits(AbstractCallMethod, _AbstractMethod);\n\n    function AbstractCallMethod(rpcMethod, parametersAmount, utils, formatters) {\n      _classCallCheck(this, AbstractCallMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(AbstractCallMethod).call(this, rpcMethod, parametersAmount, utils, formatters));\n    }\n\n    _createClass(AbstractCallMethod, [{\n      key: \"execute\",\n      value: function () {\n        var _execute = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(moduleInstance) {\n          var response, mappedResponse;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  this.beforeExecution(moduleInstance);\n\n                  if (!(this.parameters.length !== this.parametersAmount)) {\n                    _context.next = 3;\n                    break;\n                  }\n\n                  throw new Error(\"Invalid Arguments length: expected: \".concat(this.parametersAmount, \", given: \").concat(this.parameters.length));\n\n                case 3:\n                  _context.prev = 3;\n                  _context.next = 6;\n                  return moduleInstance.currentProvider.send(this.rpcMethod, this.parameters);\n\n                case 6:\n                  response = _context.sent;\n                  mappedResponse = this.afterExecution(response);\n\n                  if (this.callback) {\n                    this.callback(false, mappedResponse);\n                  }\n\n                  return _context.abrupt(\"return\", mappedResponse);\n\n                case 12:\n                  _context.prev = 12;\n                  _context.t0 = _context[\"catch\"](3);\n\n                  if (this.callback) {\n                    this.callback(_context.t0, null);\n                  }\n\n                  throw _context.t0;\n\n                case 16:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this, [[3, 12]]);\n        }));\n\n        return function execute(_x) {\n          return _execute.apply(this, arguments);\n        };\n      }()\n    }], [{\n      key: \"Type\",\n      get: function get() {\n        return 'CALL';\n      }\n    }]);\n\n    return AbstractCallMethod;\n  }(AbstractMethod);\n\n  var GetTransactionReceiptMethod = function (_AbstractCallMethod) {\n    _inherits(GetTransactionReceiptMethod, _AbstractCallMethod);\n\n    function GetTransactionReceiptMethod(utils, formatters) {\n      _classCallCheck(this, GetTransactionReceiptMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(GetTransactionReceiptMethod).call(this, 'eth_getTransactionReceipt', 1, utils, formatters));\n    }\n\n    _createClass(GetTransactionReceiptMethod, [{\n      key: \"afterExecution\",\n      value: function afterExecution(response) {\n        return this.formatters.outputTransactionFormatter(response);\n      }\n    }]);\n\n    return GetTransactionReceiptMethod;\n  }(AbstractCallMethod);\n\n  var ModuleFactory = function () {\n    function ModuleFactory(accounts, subscriptionsFactory, utils, formatters) {\n      _classCallCheck(this, ModuleFactory);\n\n      this.accounts = accounts || {};\n      this.subscriptionsFactory = subscriptionsFactory;\n      this.formatters = formatters;\n      this.utils = utils;\n    }\n\n    _createClass(ModuleFactory, [{\n      key: \"createMethodProxy\",\n      value: function createMethodProxy(target, methodFactory) {\n        return new MethodProxy(target, methodFactory);\n      }\n    }, {\n      key: \"createTransactionSigner\",\n      value: function createTransactionSigner() {\n        return new TransactionSigner(this.accounts);\n      }\n    }, {\n      key: \"createMessageSigner\",\n      value: function createMessageSigner() {\n        return new MessageSigner(this.accounts);\n      }\n    }, {\n      key: \"createTransactionConfirmationWorkflow\",\n      value: function createTransactionConfirmationWorkflow() {\n        return new TransactionConfirmationWorkflow(this.createTransactionReceiptValidator(), this.createNewHeadsWatcher(), new GetTransactionReceiptMethod(this.utils, this.formatters));\n      }\n    }, {\n      key: \"createTransactionReceiptValidator\",\n      value: function createTransactionReceiptValidator() {\n        return new TransactionReceiptValidator();\n      }\n    }, {\n      key: \"createNewHeadsWatcher\",\n      value: function createNewHeadsWatcher() {\n        return new NewHeadsWatcher(this.subscriptionsFactory);\n      }\n    }]);\n\n    return ModuleFactory;\n  }();\n\n  var AbstractMethodFactory = function () {\n    function AbstractMethodFactory(methodModuleFactory, utils, formatters) {\n      _classCallCheck(this, AbstractMethodFactory);\n\n      this.methodModuleFactory = methodModuleFactory;\n      this.utils = utils;\n      this.formatters = formatters;\n      this._methods = null;\n    }\n\n    _createClass(AbstractMethodFactory, [{\n      key: \"hasMethod\",\n      value: function hasMethod(name) {\n        return typeof this.methods[name] !== 'undefined';\n      }\n    }, {\n      key: \"createMethod\",\n      value: function createMethod(name) {\n        var method = this.methods[name];\n\n        switch (method.Type) {\n          case 'CALL':\n            if (method.name === 'SignMethod') {\n              return new method(this.utils, this.formatters, this.methodModuleFactory.accounts, this.methodModuleFactory.createMessageSigner());\n            }\n\n            return new method(this.utils, this.formatters);\n\n          case 'SEND':\n            if (method.name === 'SendTransactionMethod') {\n              return new method(this.utils, this.formatters, this.methodModuleFactory.createTransactionConfirmationWorkflow(), this.methodModuleFactory.accounts, this.methodModuleFactory.createTransactionSigner());\n            }\n\n            return new method(this.utils, this.formatters, this.methodModuleFactory.createTransactionConfirmationWorkflow());\n        }\n      }\n    }, {\n      key: \"methods\",\n      get: function get() {\n        if (this._methods) {\n          return this._methods;\n        }\n\n        throw new Error('No methods defined for MethodFactory!');\n      },\n      set: function set(value) {\n        this._methods = value;\n      }\n    }]);\n\n    return AbstractMethodFactory;\n  }();\n\n  var GetProtocolVersionMethod = function (_AbstractCallMethod) {\n    _inherits(GetProtocolVersionMethod, _AbstractCallMethod);\n\n    function GetProtocolVersionMethod(utils, formatters) {\n      _classCallCheck(this, GetProtocolVersionMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(GetProtocolVersionMethod).call(this, 'eth_protocolVersion', 0, utils, formatters));\n    }\n\n    return GetProtocolVersionMethod;\n  }(AbstractCallMethod);\n\n  var VersionMethod = function (_AbstractCallMethod) {\n    _inherits(VersionMethod, _AbstractCallMethod);\n\n    function VersionMethod(utils, formatters) {\n      _classCallCheck(this, VersionMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(VersionMethod).call(this, 'eth_protocolVersion', 0, utils, formatters));\n    }\n\n    _createClass(VersionMethod, [{\n      key: \"afterExecution\",\n      value: function afterExecution(response) {\n        return this.utils.hexToNumber(response);\n      }\n    }]);\n\n    return VersionMethod;\n  }(AbstractCallMethod);\n\n  var ListeningMethod = function (_AbstractCallMethod) {\n    _inherits(ListeningMethod, _AbstractCallMethod);\n\n    function ListeningMethod(utils, formatters) {\n      _classCallCheck(this, ListeningMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(ListeningMethod).call(this, 'net_listening', 0, utils, formatters));\n    }\n\n    return ListeningMethod;\n  }(AbstractCallMethod);\n\n  var PeerCountMethod = function (_AbstractCallMethod) {\n    _inherits(PeerCountMethod, _AbstractCallMethod);\n\n    function PeerCountMethod(utils, formatters) {\n      _classCallCheck(this, PeerCountMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(PeerCountMethod).call(this, 'net_peerCount', 0, utils, formatters));\n    }\n\n    _createClass(PeerCountMethod, [{\n      key: \"afterExecution\",\n      value: function afterExecution(response) {\n        return this.utils.hexToNumber(response);\n      }\n    }]);\n\n    return PeerCountMethod;\n  }(AbstractCallMethod);\n\n  var GetNodeInfoMethod = function (_AbstractCallMethod) {\n    _inherits(GetNodeInfoMethod, _AbstractCallMethod);\n\n    function GetNodeInfoMethod(utils, formatters) {\n      _classCallCheck(this, GetNodeInfoMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(GetNodeInfoMethod).call(this, 'web3_clientVersion', 0, utils, formatters));\n    }\n\n    return GetNodeInfoMethod;\n  }(AbstractCallMethod);\n\n  var GetCoinbaseMethod = function (_AbstractCallMethod) {\n    _inherits(GetCoinbaseMethod, _AbstractCallMethod);\n\n    function GetCoinbaseMethod(utils, formatters) {\n      _classCallCheck(this, GetCoinbaseMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(GetCoinbaseMethod).call(this, 'eth_coinbase', 0, utils, formatters));\n    }\n\n    return GetCoinbaseMethod;\n  }(AbstractCallMethod);\n\n  var IsMiningMethod = function (_AbstractCallMethod) {\n    _inherits(IsMiningMethod, _AbstractCallMethod);\n\n    function IsMiningMethod(utils, formatters) {\n      _classCallCheck(this, IsMiningMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(IsMiningMethod).call(this, 'eth_mining', 0, utils, formatters));\n    }\n\n    return IsMiningMethod;\n  }(AbstractCallMethod);\n\n  var GetHashrateMethod = function (_AbstractCallMethod) {\n    _inherits(GetHashrateMethod, _AbstractCallMethod);\n\n    function GetHashrateMethod(utils, formatters) {\n      _classCallCheck(this, GetHashrateMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(GetHashrateMethod).call(this, 'eth_hashrate', 0, utils, formatters));\n    }\n\n    _createClass(GetHashrateMethod, [{\n      key: \"afterExecution\",\n      value: function afterExecution(response) {\n        return this.utils.hexToNumber(response);\n      }\n    }]);\n\n    return GetHashrateMethod;\n  }(AbstractCallMethod);\n\n  var IsSyncingMethod = function (_AbstractCallMethod) {\n    _inherits(IsSyncingMethod, _AbstractCallMethod);\n\n    function IsSyncingMethod(utils, formatters) {\n      _classCallCheck(this, IsSyncingMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(IsSyncingMethod).call(this, 'eth_syncing', 0, utils, formatters));\n    }\n\n    _createClass(IsSyncingMethod, [{\n      key: \"afterExecution\",\n      value: function afterExecution(response) {\n        if (typeof response !== 'boolean') {\n          return this.formatters.outputSyncingFormatter(response);\n        }\n\n        return response;\n      }\n    }]);\n\n    return IsSyncingMethod;\n  }(AbstractCallMethod);\n\n  var GetGasPriceMethod = function (_AbstractCallMethod) {\n    _inherits(GetGasPriceMethod, _AbstractCallMethod);\n\n    function GetGasPriceMethod(utils, formatters) {\n      _classCallCheck(this, GetGasPriceMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(GetGasPriceMethod).call(this, 'eth_gasPrice', 0, utils, formatters));\n    }\n\n    _createClass(GetGasPriceMethod, [{\n      key: \"afterExecution\",\n      value: function afterExecution(response) {\n        return this.formatters.outputBigNumberFormatter(response);\n      }\n    }]);\n\n    return GetGasPriceMethod;\n  }(AbstractCallMethod);\n\n  var SubmitWorkMethod = function (_AbstractCallMethod) {\n    _inherits(SubmitWorkMethod, _AbstractCallMethod);\n\n    function SubmitWorkMethod(utils, formatters) {\n      _classCallCheck(this, SubmitWorkMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(SubmitWorkMethod).call(this, 'eth_submitWork', 3, utils, formatters));\n    }\n\n    return SubmitWorkMethod;\n  }(AbstractCallMethod);\n\n  var GetWorkMethod = function (_AbstractCallMethod) {\n    _inherits(GetWorkMethod, _AbstractCallMethod);\n\n    function GetWorkMethod(utils, formatters) {\n      _classCallCheck(this, GetWorkMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(GetWorkMethod).call(this, 'eth_getWork', 0, utils, formatters));\n    }\n\n    return GetWorkMethod;\n  }(AbstractCallMethod);\n\n  var GetAccountsMethod = function (_AbstractCallMethod) {\n    _inherits(GetAccountsMethod, _AbstractCallMethod);\n\n    function GetAccountsMethod(utils, formatters) {\n      _classCallCheck(this, GetAccountsMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(GetAccountsMethod).call(this, 'eth_accounts', 0, utils, formatters));\n    }\n\n    _createClass(GetAccountsMethod, [{\n      key: \"afterExecution\",\n      value: function afterExecution(response) {\n        var _this = this;\n\n        return response.map(function (responseItem) {\n          return _this.utils.toChecksumAddress(responseItem);\n        });\n      }\n    }]);\n\n    return GetAccountsMethod;\n  }(AbstractCallMethod);\n\n  var GetBalanceMethod = function (_AbstractCallMethod) {\n    _inherits(GetBalanceMethod, _AbstractCallMethod);\n\n    function GetBalanceMethod(utils, formatters) {\n      _classCallCheck(this, GetBalanceMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(GetBalanceMethod).call(this, 'eth_getBalance', 2, utils, formatters));\n    }\n\n    _createClass(GetBalanceMethod, [{\n      key: \"beforeExecution\",\n      value: function beforeExecution(moduleInstance) {\n        this.parameters[0] = this.formatters.inputAddressFormatter(this.parameters[0]);\n\n        if (isFunction(this.parameters[1])) {\n          this.callback = this.parameters[1];\n          this.parameters[1] = moduleInstance.defaultBlock;\n        }\n\n        this.parameters[1] = this.formatters.inputDefaultBlockNumberFormatter(this.parameters[1], moduleInstance);\n      }\n    }, {\n      key: \"afterExecution\",\n      value: function afterExecution(response) {\n        return this.formatters.outputBigNumberFormatter(response);\n      }\n    }]);\n\n    return GetBalanceMethod;\n  }(AbstractCallMethod);\n\n  var GetTransactionCountMethod = function (_AbstractCallMethod) {\n    _inherits(GetTransactionCountMethod, _AbstractCallMethod);\n\n    function GetTransactionCountMethod(utils, formatters) {\n      _classCallCheck(this, GetTransactionCountMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(GetTransactionCountMethod).call(this, 'eth_getTransactionCount', 2, utils, formatters));\n    }\n\n    _createClass(GetTransactionCountMethod, [{\n      key: \"beforeExecution\",\n      value: function beforeExecution(moduleInstance) {\n        this.parameters[0] = this.formatters.inputAddressFormatter(this.parameters[0]);\n\n        if (isFunction(this.parameters[1])) {\n          this.callback = this.parameters[1];\n          this.parameters[1] = moduleInstance.defaultBlock;\n        }\n\n        this.parameters[1] = this.formatters.inputDefaultBlockNumberFormatter(this.parameters[1], moduleInstance);\n      }\n    }, {\n      key: \"afterExecution\",\n      value: function afterExecution(response) {\n        return this.utils.hexToNumber(response);\n      }\n    }]);\n\n    return GetTransactionCountMethod;\n  }(AbstractCallMethod);\n\n  var RequestAccountsMethod = function (_AbstractCallMethod) {\n    _inherits(RequestAccountsMethod, _AbstractCallMethod);\n\n    function RequestAccountsMethod() {\n      _classCallCheck(this, RequestAccountsMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(RequestAccountsMethod).call(this, 'eth_requestAccounts', 0, null, null));\n    }\n\n    return RequestAccountsMethod;\n  }(AbstractCallMethod);\n\n  var GetBlockNumberMethod = function (_AbstractCallMethod) {\n    _inherits(GetBlockNumberMethod, _AbstractCallMethod);\n\n    function GetBlockNumberMethod(utils, formatters) {\n      _classCallCheck(this, GetBlockNumberMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(GetBlockNumberMethod).call(this, 'eth_blockNumber', 0, utils, formatters));\n    }\n\n    _createClass(GetBlockNumberMethod, [{\n      key: \"afterExecution\",\n      value: function afterExecution(response) {\n        return this.utils.hexToNumber(response);\n      }\n    }]);\n\n    return GetBlockNumberMethod;\n  }(AbstractCallMethod);\n\n  var GetBlockMethod = function (_AbstractCallMethod) {\n    _inherits(GetBlockMethod, _AbstractCallMethod);\n\n    function GetBlockMethod(utils, formatters) {\n      _classCallCheck(this, GetBlockMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(GetBlockMethod).call(this, 'eth_getBlockByNumber', 2, utils, formatters));\n    }\n\n    _createClass(GetBlockMethod, [{\n      key: \"beforeExecution\",\n      value: function beforeExecution(moduleInstance) {\n        if (this.isHash(this.parameters[0])) {\n          this.rpcMethod = 'eth_getBlockByHash';\n        }\n\n        this.parameters[0] = this.formatters.inputBlockNumberFormatter(this.parameters[0]);\n\n        if (isFunction(this.parameters[1])) {\n          this.callback = this.parameters[1];\n          this.parameters[1] = false;\n        } else {\n          this.parameters[1] = !!this.parameters[1];\n        }\n      }\n    }, {\n      key: \"afterExecution\",\n      value: function afterExecution(response) {\n        return this.formatters.outputBlockFormatter(response);\n      }\n    }]);\n\n    return GetBlockMethod;\n  }(AbstractCallMethod);\n\n  var GetUncleMethod = function (_AbstractCallMethod) {\n    _inherits(GetUncleMethod, _AbstractCallMethod);\n\n    function GetUncleMethod(utils, formatters) {\n      _classCallCheck(this, GetUncleMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(GetUncleMethod).call(this, 'eth_getUncleByBlockNumberAndIndex', 2, utils, formatters));\n    }\n\n    _createClass(GetUncleMethod, [{\n      key: \"beforeExecution\",\n      value: function beforeExecution(moduleInstance) {\n        if (this.isHash(this.parameters[0])) {\n          this.rpcMethod = 'eth_getUncleByBlockHashAndIndex';\n        }\n\n        this.parameters[0] = this.formatters.inputBlockNumberFormatter(this.parameters[0]);\n        this.parameters[1] = this.utils.numberToHex(this.parameters[1]);\n      }\n    }, {\n      key: \"afterExecution\",\n      value: function afterExecution(response) {\n        return this.formatters.outputBlockFormatter(response);\n      }\n    }]);\n\n    return GetUncleMethod;\n  }(AbstractCallMethod);\n\n  var GetBlockTransactionCountMethod = function (_AbstractCallMethod) {\n    _inherits(GetBlockTransactionCountMethod, _AbstractCallMethod);\n\n    function GetBlockTransactionCountMethod(utils, formatters) {\n      _classCallCheck(this, GetBlockTransactionCountMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(GetBlockTransactionCountMethod).call(this, 'eth_getTransactionByBlockNumberAndIndex', 1, utils, formatters));\n    }\n\n    _createClass(GetBlockTransactionCountMethod, [{\n      key: \"beforeExecution\",\n      value: function beforeExecution(moduleInstance) {\n        if (this.isHash(this.parameters[0])) {\n          this.rpcMethod = 'eth_getTransactionByBlockHashAndIndex';\n        }\n\n        this.parameters[0] = this.formatters.inputBlockNumberFormatter(this.parameters[0]);\n      }\n    }, {\n      key: \"afterExecution\",\n      value: function afterExecution(response) {\n        return this.utils.hexToNumber(response);\n      }\n    }]);\n\n    return GetBlockTransactionCountMethod;\n  }(AbstractCallMethod);\n\n  var GetBlockUncleCountMethod = function (_AbstractCallMethod) {\n    _inherits(GetBlockUncleCountMethod, _AbstractCallMethod);\n\n    function GetBlockUncleCountMethod(utils, formatters) {\n      _classCallCheck(this, GetBlockUncleCountMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(GetBlockUncleCountMethod).call(this, 'eth_getUncleCountByBlockNumber', 1, utils, formatters));\n    }\n\n    _createClass(GetBlockUncleCountMethod, [{\n      key: \"beforeExecution\",\n      value: function beforeExecution(moduleInstance) {\n        if (this.isHash(this.parameters[0])) {\n          this.rpcMethod = 'eth_getUncleCountByBlockHash';\n        }\n\n        this.parameters[0] = this.formatters.inputBlockNumberFormatter(this.parameters[0]);\n      }\n    }, {\n      key: \"afterExecution\",\n      value: function afterExecution(response) {\n        return this.utils.hexToNumber(response);\n      }\n    }]);\n\n    return GetBlockUncleCountMethod;\n  }(AbstractCallMethod);\n\n  var GetTransactionMethod = function (_AbstractCallMethod) {\n    _inherits(GetTransactionMethod, _AbstractCallMethod);\n\n    function GetTransactionMethod(utils, formatters) {\n      _classCallCheck(this, GetTransactionMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(GetTransactionMethod).call(this, 'eth_getTransactionByHash', 1, utils, formatters));\n    }\n\n    _createClass(GetTransactionMethod, [{\n      key: \"afterExecution\",\n      value: function afterExecution(response) {\n        return this.formatters.outputTransactionFormatter(response);\n      }\n    }]);\n\n    return GetTransactionMethod;\n  }(AbstractCallMethod);\n\n  var GetTransactionFromBlockMethod = function (_AbstractCallMethod) {\n    _inherits(GetTransactionFromBlockMethod, _AbstractCallMethod);\n\n    function GetTransactionFromBlockMethod(utils, formatters) {\n      _classCallCheck(this, GetTransactionFromBlockMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(GetTransactionFromBlockMethod).call(this, 'eth_getTransactionByBlockNumberAndIndex', 2, utils, formatters));\n    }\n\n    _createClass(GetTransactionFromBlockMethod, [{\n      key: \"beforeExecution\",\n      value: function beforeExecution(moduleInstance) {\n        if (this.isHash(this.parameters[0])) {\n          this.rpcMethod = 'eth_getTransactionByBlockHashAndIndex';\n        }\n\n        this.parameters[0] = this.formatters.inputBlockNumberFormatter(this.parameters[0]);\n        this.parameters[1] = this.utils.numberToHex(this.parameters[1]);\n      }\n    }, {\n      key: \"afterExecution\",\n      value: function afterExecution(response) {\n        return this.formatters.outputTransactionFormatter(response);\n      }\n    }]);\n\n    return GetTransactionFromBlockMethod;\n  }(AbstractCallMethod);\n\n  var AbstractSendMethod = function (_AbstractMethod) {\n    _inherits(AbstractSendMethod, _AbstractMethod);\n\n    function AbstractSendMethod(rpcMethod, parametersAmount, utils, formatters, transactionConfirmationWorkflow) {\n      var _this;\n\n      _classCallCheck(this, AbstractSendMethod);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(AbstractSendMethod).call(this, rpcMethod, parametersAmount, utils, formatters));\n      _this.transactionConfirmationWorkflow = transactionConfirmationWorkflow;\n      return _this;\n    }\n\n    _createClass(AbstractSendMethod, [{\n      key: \"execute\",\n      value: function execute(moduleInstance, promiEvent) {\n        var _this2 = this;\n\n        this.beforeExecution(moduleInstance);\n\n        if (this.parameters.length !== this.parametersAmount) {\n          throw new Error(\"Invalid Arguments length: expected: \".concat(this.parametersAmount, \", given: \").concat(this.parameters.length));\n        }\n\n        moduleInstance.currentProvider.send(this.rpcMethod, this.parameters).then(function (response) {\n          _this2.transactionConfirmationWorkflow.execute(_this2, moduleInstance, response, promiEvent);\n\n          if (_this2.callback) {\n            _this2.callback(false, response);\n          }\n\n          promiEvent.emit('transactionHash', response);\n        }).catch(function (error) {\n          if (_this2.callback) {\n            _this2.callback(error, null);\n          }\n\n          promiEvent.reject(error);\n          promiEvent.emit('error', error);\n          promiEvent.removeAllListeners();\n        });\n        return promiEvent;\n      }\n    }], [{\n      key: \"Type\",\n      get: function get() {\n        return 'SEND';\n      }\n    }]);\n\n    return AbstractSendMethod;\n  }(AbstractMethod);\n\n  var SendRawTransactionMethod = function (_AbstractSendMethod) {\n    _inherits(SendRawTransactionMethod, _AbstractSendMethod);\n\n    function SendRawTransactionMethod(utils, formatters, transactionConfirmationWorkflow) {\n      _classCallCheck(this, SendRawTransactionMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(SendRawTransactionMethod).call(this, 'eth_sendRawTransaction', 1, utils, formatters, transactionConfirmationWorkflow));\n    }\n\n    return SendRawTransactionMethod;\n  }(AbstractSendMethod);\n\n  var SignTransactionMethod = function (_AbstractCallMethod) {\n    _inherits(SignTransactionMethod, _AbstractCallMethod);\n\n    function SignTransactionMethod(utils, formatters) {\n      _classCallCheck(this, SignTransactionMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(SignTransactionMethod).call(this, 'eth_signTransaction', 1, utils, formatters));\n    }\n\n    _createClass(SignTransactionMethod, [{\n      key: \"beforeExecution\",\n      value: function beforeExecution(moduleInstance) {\n        this.parameters[0] = this.formatters.inputTransactionFormatter(this.parameters[0], moduleInstance);\n      }\n    }]);\n\n    return SignTransactionMethod;\n  }(AbstractCallMethod);\n\n  var SendTransactionMethod = function (_AbstractSendMethod) {\n    _inherits(SendTransactionMethod, _AbstractSendMethod);\n\n    function SendTransactionMethod(utils, formatters, transactionConfirmationWorkflow, accounts, transactionSigner) {\n      var _this;\n\n      _classCallCheck(this, SendTransactionMethod);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(SendTransactionMethod).call(this, 'eth_sendTransaction', 1, utils, formatters, transactionConfirmationWorkflow));\n      _this.accounts = accounts;\n      _this.transactionSigner = transactionSigner;\n      return _this;\n    }\n\n    _createClass(SendTransactionMethod, [{\n      key: \"beforeExecution\",\n      value: function beforeExecution(moduleInstance) {\n        this.parameters[0] = this.formatters.inputTransactionFormatter(this.parameters[0], moduleInstance);\n      }\n    }, {\n      key: \"execute\",\n      value: function execute(moduleInstance, promiEvent) {\n        var _this2 = this;\n\n        if (!this.isGasLimitDefined()) {\n          if (this.hasDefaultGasLimit(moduleInstance)) {\n            this.parameters[0]['gas'] = moduleInstance.defaultGas;\n          }\n        }\n\n        if (!this.isGasPriceDefined() && this.hasDefaultGasPrice(moduleInstance)) {\n          this.parameters[0]['gasPrice'] = moduleInstance.defaultGasPrice;\n        }\n\n        if (!this.isGasPriceDefined() && !this.hasDefaultGasPrice(moduleInstance)) {\n          moduleInstance.currentProvider.send('eth_gasPrice', []).then(function (gasPrice) {\n            _this2.parameters[0]['gasPrice'] = gasPrice;\n\n            _this2.execute(moduleInstance, promiEvent);\n          });\n          return promiEvent;\n        }\n\n        if (this.hasWallets()) {\n          this.rpcMethod = 'eth_sendRawTransaction';\n          this.transactionSigner.sign(this.parameters[0]).then(function (response) {\n            _this2.parameters = [response.rawTransaction];\n\n            _get(_getPrototypeOf(SendTransactionMethod.prototype), \"execute\", _this2).call(_this2, moduleInstance, promiEvent);\n          }).catch(function (error) {\n            if (_this2.callback) {\n              _this2.callback(error, null);\n            }\n\n            promiEvent.reject(error);\n            promiEvent.emit('error', error);\n            promiEvent.removeAllListeners();\n          });\n          return promiEvent;\n        }\n\n        _get(_getPrototypeOf(SendTransactionMethod.prototype), \"execute\", this).call(this, moduleInstance, promiEvent);\n\n        return promiEvent;\n      }\n    }, {\n      key: \"hasDefaultGasPrice\",\n      value: function hasDefaultGasPrice(moduleInstance) {\n        return moduleInstance.defaultGasPrice !== null && typeof moduleInstance.defaultGasPrice !== 'undefined';\n      }\n    }, {\n      key: \"isGasPriceDefined\",\n      value: function isGasPriceDefined() {\n        return isObject(this.parameters[0]) && typeof this.parameters[0].gasPrice !== 'undefined';\n      }\n    }, {\n      key: \"hasDefaultGasLimit\",\n      value: function hasDefaultGasLimit(moduleInstance) {\n        return moduleInstance.defaultGas !== null && typeof moduleInstance.defaultGas !== 'undefined';\n      }\n    }, {\n      key: \"isGasLimitDefined\",\n      value: function isGasLimitDefined() {\n        return isObject(this.parameters[0]) && typeof this.parameters[0].gas !== 'undefined';\n      }\n    }]);\n\n    return SendTransactionMethod;\n  }(AbstractSendMethod);\n\n  var GetCodeMethod = function (_AbstractCallMethod) {\n    _inherits(GetCodeMethod, _AbstractCallMethod);\n\n    function GetCodeMethod(utils, formatters) {\n      _classCallCheck(this, GetCodeMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(GetCodeMethod).call(this, 'eth_getCode', 2, utils, formatters));\n    }\n\n    _createClass(GetCodeMethod, [{\n      key: \"beforeExecution\",\n      value: function beforeExecution(moduleInstance) {\n        this.parameters[0] = this.formatters.inputAddressFormatter(this.parameters[0]);\n\n        if (isFunction(this.parameters[1])) {\n          this.callback = this.parameters[1];\n          this.parameters[1] = moduleInstance.defaultBlock;\n        }\n\n        this.parameters[1] = this.formatters.inputDefaultBlockNumberFormatter(this.parameters[1], moduleInstance);\n      }\n    }]);\n\n    return GetCodeMethod;\n  }(AbstractCallMethod);\n\n  var SignMethod = function (_AbstractCallMethod) {\n    _inherits(SignMethod, _AbstractCallMethod);\n\n    function SignMethod(utils, formatters, accounts, messageSigner) {\n      var _this;\n\n      _classCallCheck(this, SignMethod);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(SignMethod).call(this, 'eth_sign', 2, utils, formatters));\n      _this.accounts = accounts;\n      _this.messageSigner = messageSigner;\n      return _this;\n    }\n\n    _createClass(SignMethod, [{\n      key: \"execute\",\n      value: function execute(moduleInstance) {\n        if (this.hasWallets()) {\n          this.beforeExecution(moduleInstance);\n          return this.signOnClient();\n        }\n\n        return _get(_getPrototypeOf(SignMethod.prototype), \"execute\", this).call(this, moduleInstance);\n      }\n    }, {\n      key: \"signOnClient\",\n      value: function signOnClient() {\n        var signedMessage;\n\n        try {\n          signedMessage = this.afterExecution(this.messageSigner.sign(this.parameters[0], this.parameters[1]));\n        } catch (error) {\n          if (this.callback) {\n            this.callback(error, null);\n          }\n\n          throw error;\n        }\n\n        if (this.callback) {\n          this.callback(false, signedMessage);\n        }\n\n        return Promise.resolve(signedMessage);\n      }\n    }, {\n      key: \"beforeExecution\",\n      value: function beforeExecution(moduleInstance) {\n        this.parameters[0] = this.formatters.inputSignFormatter(this.parameters[0]);\n        this.parameters[1] = this.formatters.inputAddressFormatter(this.parameters[1]);\n      }\n    }]);\n\n    return SignMethod;\n  }(AbstractCallMethod);\n\n  var CallMethod = function (_AbstractCallMethod) {\n    _inherits(CallMethod, _AbstractCallMethod);\n\n    function CallMethod(utils, formatters) {\n      _classCallCheck(this, CallMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(CallMethod).call(this, 'eth_call', 2, utils, formatters));\n    }\n\n    _createClass(CallMethod, [{\n      key: \"beforeExecution\",\n      value: function beforeExecution(moduleInstance) {\n        this.parameters[0] = this.formatters.inputCallFormatter(this.parameters[0], moduleInstance);\n        this.parameters[1] = this.formatters.inputDefaultBlockNumberFormatter(this.parameters[1], moduleInstance);\n      }\n    }]);\n\n    return CallMethod;\n  }(AbstractCallMethod);\n\n  var GetStorageAtMethod = function (_AbstractCallMethod) {\n    _inherits(GetStorageAtMethod, _AbstractCallMethod);\n\n    function GetStorageAtMethod(utils, formatters) {\n      _classCallCheck(this, GetStorageAtMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(GetStorageAtMethod).call(this, 'eth_getStorageAt', 3, utils, formatters));\n    }\n\n    _createClass(GetStorageAtMethod, [{\n      key: \"beforeExecution\",\n      value: function beforeExecution(moduleInstance) {\n        this.parameters[0] = this.formatters.inputAddressFormatter(this.parameters[0]);\n        this.parameters[1] = this.utils.numberToHex(this.parameters[1]);\n\n        if (isFunction(this.parameters[2])) {\n          this.callback = this.parameters[2];\n          this.parameters[2] = moduleInstance.defaultBlock;\n        }\n\n        this.parameters[2] = this.formatters.inputDefaultBlockNumberFormatter(this.parameters[2], moduleInstance);\n      }\n    }]);\n\n    return GetStorageAtMethod;\n  }(AbstractCallMethod);\n\n  var EstimateGasMethod = function (_AbstractCallMethod) {\n    _inherits(EstimateGasMethod, _AbstractCallMethod);\n\n    function EstimateGasMethod(utils, formatters) {\n      _classCallCheck(this, EstimateGasMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(EstimateGasMethod).call(this, 'eth_estimateGas', 1, utils, formatters));\n    }\n\n    _createClass(EstimateGasMethod, [{\n      key: \"beforeExecution\",\n      value: function beforeExecution(moduleInstance) {\n        this.parameters[0] = this.formatters.inputCallFormatter(this.parameters[0], moduleInstance);\n      }\n    }, {\n      key: \"afterExecution\",\n      value: function afterExecution(response) {\n        return this.utils.hexToNumber(response);\n      }\n    }]);\n\n    return EstimateGasMethod;\n  }(AbstractCallMethod);\n\n  var GetPastLogsMethod = function (_AbstractCallMethod) {\n    _inherits(GetPastLogsMethod, _AbstractCallMethod);\n\n    function GetPastLogsMethod(utils, formatters) {\n      _classCallCheck(this, GetPastLogsMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(GetPastLogsMethod).call(this, 'eth_getLogs', 1, utils, formatters));\n    }\n\n    _createClass(GetPastLogsMethod, [{\n      key: \"beforeExecution\",\n      value: function beforeExecution(moduleInstance) {\n        this.parameters[0] = this.formatters.inputLogFormatter(this.parameters[0]);\n      }\n    }, {\n      key: \"afterExecution\",\n      value: function afterExecution(response) {\n        var _this = this;\n\n        return response.map(function (responseItem) {\n          return _this.formatters.outputLogFormatter(responseItem);\n        });\n      }\n    }]);\n\n    return GetPastLogsMethod;\n  }(AbstractCallMethod);\n\n  var EcRecoverMethod = function (_AbstractCallMethod) {\n    _inherits(EcRecoverMethod, _AbstractCallMethod);\n\n    function EcRecoverMethod(utils, formatters) {\n      _classCallCheck(this, EcRecoverMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(EcRecoverMethod).call(this, 'personal_ecRecover', 3, utils, formatters));\n    }\n\n    _createClass(EcRecoverMethod, [{\n      key: \"beforeExecution\",\n      value: function beforeExecution(moduleInstance) {\n        this.parameters[0] = this.formatters.inputSignFormatter(this.parameters[0]);\n        this.parameters[1] = this.formatters.inputAddressFormatter(this.parameters[1]);\n      }\n    }]);\n\n    return EcRecoverMethod;\n  }(AbstractCallMethod);\n\n  var ImportRawKeyMethod = function (_AbstractCallMethod) {\n    _inherits(ImportRawKeyMethod, _AbstractCallMethod);\n\n    function ImportRawKeyMethod(utils, formatters) {\n      _classCallCheck(this, ImportRawKeyMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(ImportRawKeyMethod).call(this, 'personal_importRawKey', 2, utils, formatters));\n    }\n\n    return ImportRawKeyMethod;\n  }(AbstractCallMethod);\n\n  var ListAccountsMethod = function (_AbstractCallMethod) {\n    _inherits(ListAccountsMethod, _AbstractCallMethod);\n\n    function ListAccountsMethod(utils, formatters) {\n      _classCallCheck(this, ListAccountsMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(ListAccountsMethod).call(this, 'personal_listAccounts', 0, utils, formatters));\n    }\n\n    _createClass(ListAccountsMethod, [{\n      key: \"afterExecution\",\n      value: function afterExecution(response) {\n        var _this = this;\n\n        return response.map(function (responseItem) {\n          return _this.utils.toChecksumAddress(responseItem);\n        });\n      }\n    }]);\n\n    return ListAccountsMethod;\n  }(AbstractCallMethod);\n\n  var LockAccountMethod = function (_AbstractCallMethod) {\n    _inherits(LockAccountMethod, _AbstractCallMethod);\n\n    function LockAccountMethod(utils, formatters) {\n      _classCallCheck(this, LockAccountMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(LockAccountMethod).call(this, 'personal_lockAccount', 1, utils, formatters));\n    }\n\n    _createClass(LockAccountMethod, [{\n      key: \"beforeExecution\",\n      value: function beforeExecution(moduleInstance) {\n        this.parameters[0] = this.formatters.inputAddressFormatter(this.parameters[0]);\n      }\n    }]);\n\n    return LockAccountMethod;\n  }(AbstractCallMethod);\n\n  var NewAccountMethod = function (_AbstractCallMethod) {\n    _inherits(NewAccountMethod, _AbstractCallMethod);\n\n    function NewAccountMethod(utils, formatters) {\n      _classCallCheck(this, NewAccountMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(NewAccountMethod).call(this, 'personal_newAccount', 0, utils, formatters));\n    }\n\n    _createClass(NewAccountMethod, [{\n      key: \"afterExecution\",\n      value: function afterExecution(response) {\n        return this.utils.toChecksumAddress(response);\n      }\n    }]);\n\n    return NewAccountMethod;\n  }(AbstractCallMethod);\n\n  var PersonalSendTransactionMethod = function (_AbstractCallMethod) {\n    _inherits(PersonalSendTransactionMethod, _AbstractCallMethod);\n\n    function PersonalSendTransactionMethod(utils, formatters) {\n      _classCallCheck(this, PersonalSendTransactionMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(PersonalSendTransactionMethod).call(this, 'personal_sendTransaction', 2, utils, formatters));\n    }\n\n    _createClass(PersonalSendTransactionMethod, [{\n      key: \"beforeExecution\",\n      value: function beforeExecution(moduleInstance) {\n        this.parameters[0] = this.formatters.inputTransactionFormatter(this.parameters[0], moduleInstance);\n      }\n    }]);\n\n    return PersonalSendTransactionMethod;\n  }(AbstractCallMethod);\n\n  var PersonalSignMethod = function (_AbstractCallMethod) {\n    _inherits(PersonalSignMethod, _AbstractCallMethod);\n\n    function PersonalSignMethod(utils, formatters) {\n      _classCallCheck(this, PersonalSignMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(PersonalSignMethod).call(this, 'personal_sign', 3, utils, formatters));\n    }\n\n    _createClass(PersonalSignMethod, [{\n      key: \"beforeExecution\",\n      value: function beforeExecution(moduleInstance) {\n        this.parameters[0] = this.formatters.inputSignFormatter(this.parameters[0]);\n        this.parameters[1] = this.formatters.inputAddressFormatter(this.parameters[1]);\n      }\n    }]);\n\n    return PersonalSignMethod;\n  }(AbstractCallMethod);\n\n  var PersonalSignTransactionMethod = function (_AbstractCallMethod) {\n    _inherits(PersonalSignTransactionMethod, _AbstractCallMethod);\n\n    function PersonalSignTransactionMethod(utils, formatters) {\n      _classCallCheck(this, PersonalSignTransactionMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(PersonalSignTransactionMethod).call(this, 'personal_signTransaction', 2, utils, formatters));\n    }\n\n    _createClass(PersonalSignTransactionMethod, [{\n      key: \"beforeExecution\",\n      value: function beforeExecution(moduleInstance) {\n        this.parameters[0] = this.formatters.inputTransactionFormatter(this.parameters[0], moduleInstance);\n      }\n    }]);\n\n    return PersonalSignTransactionMethod;\n  }(AbstractCallMethod);\n\n  var UnlockAccountMethod = function (_AbstractCallMethod) {\n    _inherits(UnlockAccountMethod, _AbstractCallMethod);\n\n    function UnlockAccountMethod(utils, formatters) {\n      _classCallCheck(this, UnlockAccountMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(UnlockAccountMethod).call(this, 'personal_unlockAccount', 3, utils, formatters));\n    }\n\n    _createClass(UnlockAccountMethod, [{\n      key: \"beforeExecution\",\n      value: function beforeExecution(moduleInstance) {\n        this.parameters[0] = this.formatters.inputAddressFormatter(this.parameters[0]);\n      }\n    }]);\n\n    return UnlockAccountMethod;\n  }(AbstractCallMethod);\n\n  var AddPrivateKeyMethod = function (_AbstractCallMethod) {\n    _inherits(AddPrivateKeyMethod, _AbstractCallMethod);\n\n    function AddPrivateKeyMethod(utils, formatters) {\n      _classCallCheck(this, AddPrivateKeyMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(AddPrivateKeyMethod).call(this, 'shh_addPrivateKey', 1, utils, formatters));\n    }\n\n    return AddPrivateKeyMethod;\n  }(AbstractCallMethod);\n\n  var AddSymKeyMethod = function (_AbstractCallMethod) {\n    _inherits(AddSymKeyMethod, _AbstractCallMethod);\n\n    function AddSymKeyMethod(utils, formatters) {\n      _classCallCheck(this, AddSymKeyMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(AddSymKeyMethod).call(this, 'shh_addSymKey', 1, utils, formatters));\n    }\n\n    return AddSymKeyMethod;\n  }(AbstractCallMethod);\n\n  var DeleteKeyPairMethod = function (_AbstractCallMethod) {\n    _inherits(DeleteKeyPairMethod, _AbstractCallMethod);\n\n    function DeleteKeyPairMethod(utils, formatters) {\n      _classCallCheck(this, DeleteKeyPairMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(DeleteKeyPairMethod).call(this, 'shh_deleteKeyPair', 1, utils, formatters));\n    }\n\n    return DeleteKeyPairMethod;\n  }(AbstractCallMethod);\n\n  var DeleteMessageFilterMethod = function (_AbstractCallMethod) {\n    _inherits(DeleteMessageFilterMethod, _AbstractCallMethod);\n\n    function DeleteMessageFilterMethod(utils, formatters) {\n      _classCallCheck(this, DeleteMessageFilterMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(DeleteMessageFilterMethod).call(this, 'shh_deleteMessageFilter', 1, utils, formatters));\n    }\n\n    return DeleteMessageFilterMethod;\n  }(AbstractCallMethod);\n\n  var DeleteSymKeyMethod = function (_AbstractCallMethod) {\n    _inherits(DeleteSymKeyMethod, _AbstractCallMethod);\n\n    function DeleteSymKeyMethod(utils, formatters) {\n      _classCallCheck(this, DeleteSymKeyMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(DeleteSymKeyMethod).call(this, 'shh_deleteSymKey', 1, utils, formatters));\n    }\n\n    return DeleteSymKeyMethod;\n  }(AbstractCallMethod);\n\n  var GenerateSymKeyFromPasswordMethod = function (_AbstractCallMethod) {\n    _inherits(GenerateSymKeyFromPasswordMethod, _AbstractCallMethod);\n\n    function GenerateSymKeyFromPasswordMethod(utils, formatters) {\n      _classCallCheck(this, GenerateSymKeyFromPasswordMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(GenerateSymKeyFromPasswordMethod).call(this, 'shh_generateSymKeyFromPassword', 1, utils, formatters));\n    }\n\n    return GenerateSymKeyFromPasswordMethod;\n  }(AbstractCallMethod);\n\n  var GetFilterMessagesMethod = function (_AbstractCallMethod) {\n    _inherits(GetFilterMessagesMethod, _AbstractCallMethod);\n\n    function GetFilterMessagesMethod(utils, formatters) {\n      _classCallCheck(this, GetFilterMessagesMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(GetFilterMessagesMethod).call(this, 'shh_getFilterMessages', 1, utils, formatters));\n    }\n\n    return GetFilterMessagesMethod;\n  }(AbstractCallMethod);\n\n  var GetInfoMethod = function (_AbstractCallMethod) {\n    _inherits(GetInfoMethod, _AbstractCallMethod);\n\n    function GetInfoMethod(utils, formatters) {\n      _classCallCheck(this, GetInfoMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(GetInfoMethod).call(this, 'shh_info', 0, utils, formatters));\n    }\n\n    return GetInfoMethod;\n  }(AbstractCallMethod);\n\n  var GetPrivateKeyMethod = function (_AbstractCallMethod) {\n    _inherits(GetPrivateKeyMethod, _AbstractCallMethod);\n\n    function GetPrivateKeyMethod(utils, formatters) {\n      _classCallCheck(this, GetPrivateKeyMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(GetPrivateKeyMethod).call(this, 'shh_getPrivateKey', 1, utils, formatters));\n    }\n\n    return GetPrivateKeyMethod;\n  }(AbstractCallMethod);\n\n  var GetPublicKeyMethod = function (_AbstractCallMethod) {\n    _inherits(GetPublicKeyMethod, _AbstractCallMethod);\n\n    function GetPublicKeyMethod(utils, formatters) {\n      _classCallCheck(this, GetPublicKeyMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(GetPublicKeyMethod).call(this, 'shh_getPublicKey', 1, utils, formatters));\n    }\n\n    return GetPublicKeyMethod;\n  }(AbstractCallMethod);\n\n  var GetSymKeyMethod = function (_AbstractCallMethod) {\n    _inherits(GetSymKeyMethod, _AbstractCallMethod);\n\n    function GetSymKeyMethod(utils, formatters) {\n      _classCallCheck(this, GetSymKeyMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(GetSymKeyMethod).call(this, 'shh_getSymKey', 1, utils, formatters));\n    }\n\n    return GetSymKeyMethod;\n  }(AbstractCallMethod);\n\n  var HasKeyPairMethod = function (_AbstractCallMethod) {\n    _inherits(HasKeyPairMethod, _AbstractCallMethod);\n\n    function HasKeyPairMethod(utils, formatters) {\n      _classCallCheck(this, HasKeyPairMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(HasKeyPairMethod).call(this, 'shh_hasKeyPair', 1, utils, formatters));\n    }\n\n    return HasKeyPairMethod;\n  }(AbstractCallMethod);\n\n  var HasSymKeyMethod = function (_AbstractCallMethod) {\n    _inherits(HasSymKeyMethod, _AbstractCallMethod);\n\n    function HasSymKeyMethod(utils, formatters) {\n      _classCallCheck(this, HasSymKeyMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(HasSymKeyMethod).call(this, 'shh_hasSymKey', 1, utils, formatters));\n    }\n\n    return HasSymKeyMethod;\n  }(AbstractCallMethod);\n\n  var MarkTrustedPeerMethod = function (_AbstractCallMethod) {\n    _inherits(MarkTrustedPeerMethod, _AbstractCallMethod);\n\n    function MarkTrustedPeerMethod(utils, formatters) {\n      _classCallCheck(this, MarkTrustedPeerMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(MarkTrustedPeerMethod).call(this, 'shh_markTrustedPeer', 1, utils, formatters));\n    }\n\n    return MarkTrustedPeerMethod;\n  }(AbstractCallMethod);\n\n  var NewKeyPairMethod = function (_AbstractCallMethod) {\n    _inherits(NewKeyPairMethod, _AbstractCallMethod);\n\n    function NewKeyPairMethod(utils, formatters) {\n      _classCallCheck(this, NewKeyPairMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(NewKeyPairMethod).call(this, 'shh_newKeyPair', 1, utils, formatters));\n    }\n\n    return NewKeyPairMethod;\n  }(AbstractCallMethod);\n\n  var NewMessageFilterMethod = function (_AbstractCallMethod) {\n    _inherits(NewMessageFilterMethod, _AbstractCallMethod);\n\n    function NewMessageFilterMethod(utils, formatters) {\n      _classCallCheck(this, NewMessageFilterMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(NewMessageFilterMethod).call(this, 'shh_newMessageFilter', 1, utils, formatters));\n    }\n\n    return NewMessageFilterMethod;\n  }(AbstractCallMethod);\n\n  var NewSymKeyMethod = function (_AbstractCallMethod) {\n    _inherits(NewSymKeyMethod, _AbstractCallMethod);\n\n    function NewSymKeyMethod(utils, formatters) {\n      _classCallCheck(this, NewSymKeyMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(NewSymKeyMethod).call(this, 'shh_newSymKey', 0, utils, formatters));\n    }\n\n    return NewSymKeyMethod;\n  }(AbstractCallMethod);\n\n  var PostMethod = function (_AbstractCallMethod) {\n    _inherits(PostMethod, _AbstractCallMethod);\n\n    function PostMethod(utils, formatters) {\n      _classCallCheck(this, PostMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(PostMethod).call(this, 'shh_post', 1, utils, formatters));\n    }\n\n    return PostMethod;\n  }(AbstractCallMethod);\n\n  var SetMaxMessageSizeMethod = function (_AbstractCallMethod) {\n    _inherits(SetMaxMessageSizeMethod, _AbstractCallMethod);\n\n    function SetMaxMessageSizeMethod(utils, formatters) {\n      _classCallCheck(this, SetMaxMessageSizeMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(SetMaxMessageSizeMethod).call(this, 'shh_setMaxMessageSize', 1, utils, formatters));\n    }\n\n    return SetMaxMessageSizeMethod;\n  }(AbstractCallMethod);\n\n  var SetMinPoWMethod = function (_AbstractCallMethod) {\n    _inherits(SetMinPoWMethod, _AbstractCallMethod);\n\n    function SetMinPoWMethod(utils, formatters) {\n      _classCallCheck(this, SetMinPoWMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(SetMinPoWMethod).call(this, 'shh_setMinPoW', 1, utils, formatters));\n    }\n\n    return SetMinPoWMethod;\n  }(AbstractCallMethod);\n\n  var ShhVersionMethod = function (_AbstractCallMethod) {\n    _inherits(ShhVersionMethod, _AbstractCallMethod);\n\n    function ShhVersionMethod(utils, formatters) {\n      _classCallCheck(this, ShhVersionMethod);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(ShhVersionMethod).call(this, 'shh_version', 0, utils, formatters));\n    }\n\n    return ShhVersionMethod;\n  }(AbstractCallMethod);\n\n  var MethodModuleFactory = function MethodModuleFactory(accounts) {\n    return new ModuleFactory(accounts, new web3CoreSubscriptions.SubscriptionsFactory(), Utils, web3CoreHelpers.formatters);\n  };\n\n  exports.MethodModuleFactory = MethodModuleFactory;\n  exports.AbstractMethod = AbstractMethod;\n  exports.AbstractMethodFactory = AbstractMethodFactory;\n  exports.GetProtocolVersionMethod = GetProtocolVersionMethod;\n  exports.VersionMethod = VersionMethod;\n  exports.ListeningMethod = ListeningMethod;\n  exports.PeerCountMethod = PeerCountMethod;\n  exports.GetNodeInfoMethod = GetNodeInfoMethod;\n  exports.GetCoinbaseMethod = GetCoinbaseMethod;\n  exports.IsMiningMethod = IsMiningMethod;\n  exports.GetHashrateMethod = GetHashrateMethod;\n  exports.IsSyncingMethod = IsSyncingMethod;\n  exports.GetGasPriceMethod = GetGasPriceMethod;\n  exports.SubmitWorkMethod = SubmitWorkMethod;\n  exports.GetWorkMethod = GetWorkMethod;\n  exports.GetAccountsMethod = GetAccountsMethod;\n  exports.GetBalanceMethod = GetBalanceMethod;\n  exports.GetTransactionCountMethod = GetTransactionCountMethod;\n  exports.RequestAccountsMethod = RequestAccountsMethod;\n  exports.GetBlockNumberMethod = GetBlockNumberMethod;\n  exports.GetBlockMethod = GetBlockMethod;\n  exports.GetUncleMethod = GetUncleMethod;\n  exports.GetBlockTransactionCountMethod = GetBlockTransactionCountMethod;\n  exports.GetBlockUncleCountMethod = GetBlockUncleCountMethod;\n  exports.GetTransactionMethod = GetTransactionMethod;\n  exports.GetTransactionFromBlockMethod = GetTransactionFromBlockMethod;\n  exports.GetTransactionReceipt = GetTransactionReceiptMethod;\n  exports.SendRawTransactionMethod = SendRawTransactionMethod;\n  exports.SignTransactionMethod = SignTransactionMethod;\n  exports.SendTransactionMethod = SendTransactionMethod;\n  exports.GetCodeMethod = GetCodeMethod;\n  exports.SignMethod = SignMethod;\n  exports.CallMethod = CallMethod;\n  exports.GetStorageAtMethod = GetStorageAtMethod;\n  exports.EstimateGasMethod = EstimateGasMethod;\n  exports.GetPastLogsMethod = GetPastLogsMethod;\n  exports.EcRecoverMethod = EcRecoverMethod;\n  exports.ImportRawKeyMethod = ImportRawKeyMethod;\n  exports.ListAccountsMethod = ListAccountsMethod;\n  exports.LockAccountMethod = LockAccountMethod;\n  exports.NewAccountMethod = NewAccountMethod;\n  exports.PersonalSendTransactionMethod = PersonalSendTransactionMethod;\n  exports.PersonalSignMethod = PersonalSignMethod;\n  exports.PersonalSignTransactionMethod = PersonalSignTransactionMethod;\n  exports.UnlockAccountMethod = UnlockAccountMethod;\n  exports.AddPrivateKeyMethod = AddPrivateKeyMethod;\n  exports.AddSymKeyMethod = AddSymKeyMethod;\n  exports.DeleteKeyPairMethod = DeleteKeyPairMethod;\n  exports.DeleteMessageFilterMethod = DeleteMessageFilterMethod;\n  exports.DeleteSymKeyMethod = DeleteSymKeyMethod;\n  exports.GenerateSymKeyFromPasswordMethod = GenerateSymKeyFromPasswordMethod;\n  exports.GetFilterMessagesMethod = GetFilterMessagesMethod;\n  exports.GetInfoMethod = GetInfoMethod;\n  exports.GetPrivateKeyMethod = GetPrivateKeyMethod;\n  exports.GetPublicKeyMethod = GetPublicKeyMethod;\n  exports.GetSymKeyMethod = GetSymKeyMethod;\n  exports.HasKeyPairMethod = HasKeyPairMethod;\n  exports.HasSymKeyMethod = HasSymKeyMethod;\n  exports.MarkTrustedPeerMethod = MarkTrustedPeerMethod;\n  exports.NewKeyPairMethod = NewKeyPairMethod;\n  exports.NewMessageFilterMethod = NewMessageFilterMethod;\n  exports.NewSymKeyMethod = NewSymKeyMethod;\n  exports.PostMethod = PostMethod;\n  exports.SetMaxMessageSizeMethod = SetMaxMessageSizeMethod;\n  exports.SetMinPoWMethod = SetMinPoWMethod;\n  exports.ShhVersionMethod = ShhVersionMethod;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}